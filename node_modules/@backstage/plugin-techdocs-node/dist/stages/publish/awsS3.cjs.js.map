{"version":3,"file":"awsS3.cjs.js","sources":["../../../src/stages/publish/awsS3.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Entity, CompoundEntityRef } from '@backstage/catalog-model';\nimport { Config } from '@backstage/config';\nimport { assertError, ForwardedError } from '@backstage/errors';\n\n// Maximum size in bytes for a single upload part (5MB)\nconst MAX_SINGLE_UPLOAD_BYTES = 5 * 1024 * 1024;\n\nimport {\n  AwsCredentialsManager,\n  DefaultAwsCredentialsManager,\n} from '@backstage/integration-aws-node';\nimport {\n  GetObjectCommand,\n  CopyObjectCommand,\n  DeleteObjectCommand,\n  HeadBucketCommand,\n  HeadObjectCommand,\n  PutObjectCommand,\n  PutObjectCommandInput,\n  ListObjectsV2CommandOutput,\n  ListObjectsV2Command,\n  S3Client,\n  S3ServiceException,\n} from '@aws-sdk/client-s3';\nimport { fromTemporaryCredentials } from '@aws-sdk/credential-providers';\nimport { NodeHttpHandler } from '@smithy/node-http-handler';\nimport { Upload } from '@aws-sdk/lib-storage';\nimport { AwsCredentialIdentityProvider } from '@aws-sdk/types';\nimport { HttpsProxyAgent } from 'hpagent';\nimport express from 'express';\nimport fs from 'fs-extra';\nimport JSON5 from 'json5';\nimport createLimiter from 'p-limit';\nimport path from 'path';\nimport { Readable } from 'stream';\nimport {\n  bulkStorageOperation,\n  getCloudPathForLocalPath,\n  getFileTreeRecursively,\n  getHeadersForFileExtension,\n  getStaleFiles,\n  isValidContentPath,\n  lowerCaseEntityTriplet,\n  lowerCaseEntityTripletInStoragePath,\n  normalizeExternalStorageRootPath,\n} from './helpers';\nimport {\n  PublisherBase,\n  PublishRequest,\n  PublishResponse,\n  ReadinessResponse,\n  TechDocsMetadata,\n} from './types';\nimport { LoggerService } from '@backstage/backend-plugin-api';\nimport { AwsS3Integration, ScmIntegrations } from '@backstage/integration';\n\nconst streamToBuffer = (stream: Readable): Promise<Buffer> => {\n  return new Promise((resolve, reject) => {\n    try {\n      const chunks: any[] = [];\n      stream.on('data', chunk => chunks.push(chunk));\n      stream.on('error', (e: Error) =>\n        reject(new ForwardedError('Unable to read stream', e)),\n      );\n      stream.on('end', () => resolve(Buffer.concat(chunks)));\n    } catch (e) {\n      throw new ForwardedError('Unable to parse the response data', e);\n    }\n  });\n};\n\nexport class AwsS3Publish implements PublisherBase {\n  public readonly storageClient: S3Client;\n  private readonly bucketName: string;\n  private readonly legacyPathCasing: boolean;\n  private readonly logger: LoggerService;\n  private readonly bucketRootPath: string;\n  private readonly sse?: 'aws:kms' | 'AES256';\n  private readonly maxAttempts: number;\n\n  constructor(options: {\n    storageClient: S3Client;\n    bucketName: string;\n    legacyPathCasing: boolean;\n    logger: LoggerService;\n    bucketRootPath: string;\n    sse?: 'aws:kms' | 'AES256';\n    maxAttempts: number;\n  }) {\n    this.storageClient = options.storageClient;\n    this.bucketName = options.bucketName;\n    this.legacyPathCasing = options.legacyPathCasing;\n    this.logger = options.logger;\n    this.bucketRootPath = options.bucketRootPath;\n    this.sse = options.sse;\n    this.maxAttempts = options.maxAttempts;\n  }\n\n  static async fromConfig(\n    config: Config,\n    logger: LoggerService,\n  ): Promise<PublisherBase> {\n    let bucketName = '';\n    try {\n      bucketName = config.getString('techdocs.publisher.awsS3.bucketName');\n    } catch (error) {\n      throw new Error(\n        \"Since techdocs.publisher.type is set to 'awsS3' in your app config, \" +\n          'techdocs.publisher.awsS3.bucketName is required.',\n      );\n    }\n\n    const bucketRootPath = normalizeExternalStorageRootPath(\n      config.getOptionalString('techdocs.publisher.awsS3.bucketRootPath') || '',\n    );\n\n    const sse = config.getOptionalString('techdocs.publisher.awsS3.sse') as\n      | 'aws:kms'\n      | 'AES256'\n      | undefined;\n\n    // AWS Region is an optional config. If missing, default AWS env variable AWS_REGION\n    // or AWS shared credentials file at ~/.aws/credentials will be used.\n    const region = config.getOptionalString('techdocs.publisher.awsS3.region');\n\n    // Credentials can optionally be configured by specifying the AWS account ID, which will retrieve credentials\n    // for the account from the 'aws' section of the app config.\n    // Credentials can also optionally be directly configured in the techdocs awsS3 config, but this method is\n    // deprecated.\n    // If no credentials are configured, the AWS SDK V3's default credential chain will be used.\n    const accountId = config.getOptionalString(\n      'techdocs.publisher.awsS3.accountId',\n    );\n    const credentialsConfig = config.getOptionalConfig(\n      'techdocs.publisher.awsS3.credentials',\n    );\n\n    const credsManager = DefaultAwsCredentialsManager.fromConfig(config);\n\n    const scmIntegrations = ScmIntegrations.fromConfig(config);\n    const awsS3Integrations = scmIntegrations.awsS3.list();\n\n    const sdkCredentialProvider = await AwsS3Publish.buildCredentials(\n      credsManager,\n      logger,\n      awsS3Integrations,\n      accountId,\n      credentialsConfig,\n      region,\n    );\n\n    // AWS endpoint is an optional config. If missing, the default endpoint is built from\n    // the configured region.\n    const endpoint = config.getOptionalString(\n      'techdocs.publisher.awsS3.endpoint',\n    );\n\n    // AWS HTTPS proxy is an optional config. If missing, no proxy is used\n    const httpsProxy = config.getOptionalString(\n      'techdocs.publisher.awsS3.httpsProxy',\n    );\n\n    // AWS forcePathStyle is an optional config. If missing, it defaults to false. Needs to be enabled for cases\n    // where endpoint url points to locally hosted S3 compatible storage like Localstack\n    const forcePathStyle = config.getOptionalBoolean(\n      'techdocs.publisher.awsS3.s3ForcePathStyle',\n    );\n\n    // AWS MAX ATTEMPTS is an optional config. If missing, default value of 5 is used\n    const maxAttempts = config.getOptionalNumber(\n      'techdocs.publisher.awsS3.maxAttempts',\n    );\n\n    const storageClient = new S3Client({\n      customUserAgent: 'backstage-aws-techdocs-s3-publisher',\n      credentialDefaultProvider: () => sdkCredentialProvider,\n      ...(region && { region }),\n      ...(endpoint && { endpoint }),\n      ...(forcePathStyle && { forcePathStyle }),\n      // Enhanced retry configuration for better reliability\n      maxAttempts: maxAttempts || 5,\n      retryMode: 'adaptive',\n      // Enhanced connection settings for large file uploads\n      requestHandler: new NodeHttpHandler({\n        ...(httpsProxy && {\n          httpsAgent: new HttpsProxyAgent({ proxy: httpsProxy }),\n        }),\n        connectionTimeout: 60000,\n        socketTimeout: 120000,\n      }),\n    });\n\n    const legacyPathCasing =\n      config.getOptionalBoolean(\n        'techdocs.legacyUseCaseSensitiveTripletPaths',\n      ) || false;\n\n    return new AwsS3Publish({\n      storageClient,\n      bucketName,\n      bucketRootPath,\n      legacyPathCasing,\n      logger,\n      sse,\n      maxAttempts: maxAttempts || 5,\n    });\n  }\n\n  private static buildStaticCredentials(\n    accessKeyId: string,\n    secretAccessKey: string,\n  ): AwsCredentialIdentityProvider {\n    return async () => {\n      return Promise.resolve({\n        accessKeyId,\n        secretAccessKey,\n      });\n    };\n  }\n\n  private static async buildCredentials(\n    credsManager: AwsCredentialsManager,\n    logger: LoggerService,\n    awsS3Integrations: AwsS3Integration[],\n    accountId?: string,\n    credentialsConfig?: Config,\n    region?: string,\n  ): Promise<AwsCredentialIdentityProvider> {\n    // Pull credentials for the specified account ID from the 'aws' config section\n    if (accountId) {\n      return (await credsManager.getCredentialProvider({ accountId }))\n        .sdkCredentialProvider;\n    }\n\n    const explicitCredentials = await AwsS3Publish.getExplicitCredentials({\n      credsManager,\n      credentialsConfig,\n      awsS3Integrations,\n      logger,\n    });\n\n    const roleArn = credentialsConfig?.getOptionalString('roleArn');\n    if (roleArn) {\n      return fromTemporaryCredentials({\n        masterCredentials: explicitCredentials,\n        params: {\n          RoleSessionName: 'backstage-aws-techdocs-s3-publisher',\n          RoleArn: roleArn,\n        },\n        clientConfig: { region },\n      });\n    }\n\n    return explicitCredentials;\n  }\n  /**\n   * Custom retry wrapper for S3 operations with detailed error handling.\n   */\n  public async retryOperation<TOutput>(\n    operation: () => Promise<TOutput>,\n    operationName: string,\n    maxAttempts: number = 3,\n    shouldRetry: (\n      error: S3ServiceException,\n    ) => boolean = this.defaultShouldRetry.bind(this),\n  ): Promise<TOutput> {\n    for (let attempt = 1; attempt < maxAttempts; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        const e = error as S3ServiceException;\n        if (!shouldRetry(e)) {\n          this.logger.error(`${operationName} failed: ${e.message}`);\n          throw e;\n        }\n\n        this.logger.warn(`${operationName} failed, retrying...`, {\n          attempt,\n          maxAttempts,\n          error: e.message,\n          errorCode: e.name,\n          httpStatusCode: e.$metadata?.httpStatusCode,\n        });\n\n        // Enhanced exponential backoff with jitter\n        const baseDelay = operationName.startsWith('Upload-') ? 2000 : 1000;\n        const backoffDelay = Math.min(\n          baseDelay * Math.pow(2, attempt - 1),\n          30000,\n        );\n        const jitter = Math.random() * 1000;\n        await new Promise(resolve =>\n          setTimeout(resolve, backoffDelay + jitter),\n        );\n      }\n    }\n    return await operation();\n  }\n\n  /**\n   * Determines if an S3 operation should be retried based on the error details.\n   */\n  private defaultShouldRetry(error: S3ServiceException): boolean {\n    const httpStatusCode = error.$metadata?.httpStatusCode;\n    const errorCode = error.name;\n\n    // Truly transient errors that should always be retried\n    const transientErrors = [\n      'NetworkingError',\n      'TimeoutError',\n      'ConnectionError',\n      'RequestTimeout',\n      'ServiceUnavailable',\n      'SlowDown',\n      'ThrottlingException',\n    ];\n\n    // Server errors are always considered transient\n    if (httpStatusCode && httpStatusCode >= 500) {\n      return true;\n    }\n\n    // Specific 4xx errors that are known to be transient\n    if (httpStatusCode && httpStatusCode >= 400 && httpStatusCode < 500) {\n      const retriable4xxErrors = [\n        'RequestTimeout',\n        'RequestTimeoutException',\n        'PriorRequestNotComplete',\n      ];\n      return retriable4xxErrors.includes(errorCode);\n    }\n\n    // Check against known transient errors\n    return transientErrors.some(\n      retriableError =>\n        errorCode === retriableError || error.message.includes(retriableError),\n    );\n  }\n\n  private static async getExplicitCredentials({\n    credentialsConfig,\n    awsS3Integrations,\n    credsManager,\n    logger,\n  }: {\n    credentialsConfig?: Config;\n    awsS3Integrations: AwsS3Integration[];\n    credsManager: AwsCredentialsManager;\n    logger: LoggerService;\n  }): Promise<AwsCredentialIdentityProvider> {\n    const accessKeyId = credentialsConfig?.getOptionalString('accessKeyId');\n    const secretAccessKey =\n      credentialsConfig?.getOptionalString('secretAccessKey');\n\n    if (accessKeyId && secretAccessKey) {\n      return AwsS3Publish.buildStaticCredentials(accessKeyId, secretAccessKey);\n    }\n\n    if (awsS3Integrations.length > 0) {\n      if (awsS3Integrations.length === 1) {\n        const singleAwsS3IntegrationConfig = awsS3Integrations[0].config;\n\n        const singleAwsS3IntegrationAccessKeyId =\n          singleAwsS3IntegrationConfig.accessKeyId;\n\n        const singleAwsS3IntegrationSecretAccessKey =\n          singleAwsS3IntegrationConfig.secretAccessKey;\n\n        if (\n          singleAwsS3IntegrationAccessKeyId &&\n          singleAwsS3IntegrationSecretAccessKey\n        ) {\n          return AwsS3Publish.buildStaticCredentials(\n            singleAwsS3IntegrationAccessKeyId,\n            singleAwsS3IntegrationSecretAccessKey,\n          );\n        }\n      } else {\n        if (accessKeyId) {\n          const targetAwsS3IntegrationConfig = awsS3Integrations.find(\n            c => c.config.accessKeyId === accessKeyId,\n          );\n\n          if (!targetAwsS3IntegrationConfig) {\n            logger.warn(\n              `No AWS S3 integration config under integrations.awsS3 found for access key id ${accessKeyId}.`,\n            );\n          }\n          const targetAwsS3IntegrationAccessKeyId =\n            targetAwsS3IntegrationConfig?.config.accessKeyId;\n          const targetAwsS3IntegrationSecretAccessKey =\n            targetAwsS3IntegrationConfig?.config.secretAccessKey;\n          if (\n            targetAwsS3IntegrationAccessKeyId &&\n            targetAwsS3IntegrationSecretAccessKey\n          ) {\n            return AwsS3Publish.buildStaticCredentials(\n              targetAwsS3IntegrationAccessKeyId,\n              targetAwsS3IntegrationSecretAccessKey,\n            );\n          }\n        }\n      }\n    }\n    return (await credsManager.getCredentialProvider()).sdkCredentialProvider;\n  }\n\n  /**\n   * Check if the defined bucket exists. Being able to connect means the configuration is good\n   * and the storage client will work.\n   */\n  async getReadiness(): Promise<ReadinessResponse> {\n    try {\n      await this.storageClient.send(\n        new HeadBucketCommand({ Bucket: this.bucketName }),\n      );\n\n      this.logger.info(\n        `Successfully connected to the AWS S3 bucket ${this.bucketName}.`,\n      );\n\n      return { isAvailable: true };\n    } catch (error) {\n      this.logger.error(\n        `Could not retrieve metadata about the AWS S3 bucket ${this.bucketName}. ` +\n          'Make sure the bucket exists. Also make sure that authentication is setup either by ' +\n          'explicitly defining credentials and region in techdocs.publisher.awsS3 in app config or ' +\n          'by using environment variables. Refer to https://backstage.io/docs/features/techdocs/using-cloud-storage',\n      );\n      this.logger.error(\n        `from AWS client library`,\n        error instanceof Error ? error : new Error(String(error)),\n      );\n      return {\n        isAvailable: false,\n      };\n    }\n  }\n  /**\n   * Upload all the files from the generated `directory` to the S3 bucket.\n   * Directory structure used in the bucket is - entityNamespace/entityKind/entityName/index.html\n   */\n  async publish({\n    entity,\n    directory,\n  }: PublishRequest): Promise<PublishResponse> {\n    const objects: string[] = [];\n    const useLegacyPathCasing = this.legacyPathCasing;\n    const bucketRootPath = this.bucketRootPath;\n    const sse = this.sse;\n\n    // Track timing for performance monitoring\n    const publishStartTime = Date.now();\n\n    // First, try to retrieve a list of all individual files currently existing\n    let existingFiles: string[] = [];\n    try {\n      const remoteFolder = getCloudPathForLocalPath(\n        entity,\n        undefined,\n        useLegacyPathCasing,\n        bucketRootPath,\n      );\n      const response = await this.retryOperation(\n        async () => {\n          const listCommand = new ListObjectsV2Command({\n            Bucket: this.bucketName,\n            Prefix: remoteFolder,\n          });\n          return this.storageClient.send(listCommand);\n        },\n        'ListObjects',\n        this.maxAttempts,\n      );\n      existingFiles = (response.Contents || [])\n        .map(f => f.Key || '')\n        .filter(f => !!f);\n    } catch (e) {\n      assertError(e);\n      this.logger.error(\n        `Unable to list files for Entity ${entity.metadata.name}: ${e.message}`,\n      );\n    }\n\n    // Then, merge new files into the same folder\n    let absoluteFilesToUpload;\n    try {\n      // Remove the absolute path prefix of the source directory\n      // Path of all files to upload, relative to the root of the source directory\n      // e.g. ['index.html', 'sub-page/index.html', 'assets/images/favicon.png']\n      absoluteFilesToUpload = await getFileTreeRecursively(directory);\n\n      await bulkStorageOperation(\n        async absoluteFilePath => {\n          const relativeFilePath = path.relative(directory, absoluteFilePath);\n          const s3Key = getCloudPathForLocalPath(\n            entity,\n            relativeFilePath,\n            useLegacyPathCasing,\n            bucketRootPath,\n          );\n          // Create params without the Body because the body must be the\n          // actual file contents (Buffer or Readable), not the path string.\n          // For multipart uploads we attach a Readable stream to avoid\n          // buffering large files in memory. For simple uploads we attach\n          // a Buffer read from disk.\n          const params: PutObjectCommandInput = {\n            Bucket: this.bucketName,\n            Key: s3Key,\n            ...(sse && { ServerSideEncryption: sse }),\n          };\n\n          objects.push(params.Key!);\n          // Get file stats before upload\n          const stats = await fs.stat(absoluteFilePath);\n          const fileSizeInBytes = stats.size;\n\n          // Check if this is a large file that requires multipart upload\n          if (fileSizeInBytes >= MAX_SINGLE_UPLOAD_BYTES) {\n            // Try multipart upload for large files\n            try {\n              // Create stream and Upload inside retry closure so stream is\n              // recreated on each retry attempt (streams are consumable once).\n              await this.retryOperation(\n                () => {\n                  // Create a fresh stream on each attempt\n                  const fileStream = fs.createReadStream(absoluteFilePath);\n                  const uploadParams = { ...params, Body: fileStream };\n\n                  const upload = new Upload({\n                    client: this.storageClient,\n                    params: uploadParams,\n                    partSize: MAX_SINGLE_UPLOAD_BYTES,\n                    queueSize: 3,\n                    leavePartsOnError: false,\n                  });\n                  return upload.done();\n                },\n                `Upload-${params.Key}`,\n                this.maxAttempts,\n              );\n              return;\n            } catch (multipartError) {\n              const s3Error = multipartError as any;\n              const errorName = s3Error?.name || 'Unknown';\n\n              // For specific multipart errors, attempt simple upload fallback\n              if (errorName === 'InvalidPart' || errorName === 'NoSuchUpload') {\n                this.logger.warn(\n                  `Multipart upload failed for ${params.Key}, attempting simple upload fallback.`,\n                );\n              } else {\n                // Non-recoverable multipart error, throw it\n                this.logger.error(\n                  `Multipart upload failed for ${params.Key}: ${\n                    multipartError instanceof Error\n                      ? multipartError.message\n                      : String(multipartError)\n                  }`,\n                );\n                throw multipartError;\n              }\n            }\n          }\n\n          // Use simple upload for small files or as fallback from multipart\n          try {\n            const fileContent = await fs.readFile(absoluteFilePath);\n            const putParams = { ...params, Body: fileContent };\n            await this.retryOperation(\n              () => this.storageClient.send(new PutObjectCommand(putParams)),\n              `Upload-${params.Key}`,\n              this.maxAttempts,\n            );\n\n            if (fileSizeInBytes >= MAX_SINGLE_UPLOAD_BYTES) {\n              this.logger.info(\n                `Simple upload fallback succeeded for ${params.Key}`,\n              );\n            }\n          } catch (error) {\n            this.logger.error(\n              `Upload failed for ${params.Key}: ${\n                error instanceof Error ? error.message : String(error)\n              }`,\n            );\n            throw error;\n          }\n        },\n        absoluteFilesToUpload,\n        { concurrencyLimit: 10 },\n      );\n\n      this.logger.info(\n        `Successfully uploaded all the generated files for Entity ${entity.metadata.name}. Total number of files: ${absoluteFilesToUpload.length}`,\n      );\n    } catch (e) {\n      const errorMessage = `Unable to upload file(s) to AWS S3. ${e}`;\n      this.logger.error(errorMessage);\n      throw new Error(errorMessage);\n    }\n\n    // Last, try to remove the files that were *only* present previously\n    try {\n      const relativeFilesToUpload = absoluteFilesToUpload.map(\n        absoluteFilePath =>\n          getCloudPathForLocalPath(\n            entity,\n            path.relative(directory, absoluteFilePath),\n            useLegacyPathCasing,\n            bucketRootPath,\n          ),\n      );\n      const staleFiles = getStaleFiles(relativeFilesToUpload, existingFiles);\n\n      await bulkStorageOperation(\n        async relativeFilePath => {\n          return this.retryOperation(\n            async () => {\n              const deleteCommand = new DeleteObjectCommand({\n                Bucket: this.bucketName,\n                Key: relativeFilePath,\n              });\n              return this.storageClient.send(deleteCommand);\n            },\n            'DeleteObject',\n            this.maxAttempts,\n          );\n        },\n        staleFiles,\n        { concurrencyLimit: 10 },\n      );\n      this.logger.info(\n        `Successfully deleted stale files for Entity ${entity.metadata.name}. Total number of files: ${staleFiles.length}`,\n      );\n    } catch (error) {\n      const errorMessage = `Unable to delete file(s) from AWS S3. ${error}`;\n      this.logger.error(errorMessage);\n    }\n    const publishEndTime = Date.now();\n    const publishDurationMs = publishEndTime - publishStartTime;\n    this.logger.info(\n      `Successfully published ${objects.length} files for ${\n        entity.metadata.name\n      } in ${Math.round(publishDurationMs / 1000)}s`,\n    );\n    return { objects };\n  }\n\n  async fetchTechDocsMetadata(\n    entityName: CompoundEntityRef,\n  ): Promise<TechDocsMetadata> {\n    try {\n      return await new Promise<TechDocsMetadata>(async (resolve, reject) => {\n        const entityTriplet = `${entityName.namespace}/${entityName.kind}/${entityName.name}`;\n        const entityDir = this.legacyPathCasing\n          ? entityTriplet\n          : lowerCaseEntityTriplet(entityTriplet);\n\n        const entityRootDir = path.posix.join(this.bucketRootPath, entityDir);\n        if (!isValidContentPath(this.bucketRootPath, entityRootDir)) {\n          this.logger.error(\n            `Invalid content path found while fetching TechDocs metadata: ${entityRootDir}`,\n          );\n          throw new Error(`Metadata Not Found`);\n        }\n\n        try {\n          const resp = await this.retryOperation(\n            async () => {\n              const getCommand = new GetObjectCommand({\n                Bucket: this.bucketName,\n                Key: `${entityRootDir}/techdocs_metadata.json`,\n              });\n              return this.storageClient.send(getCommand);\n            },\n            'GetTechDocsMetadata',\n            this.maxAttempts,\n          );\n\n          const techdocsMetadataJson = await streamToBuffer(\n            resp.Body as Readable,\n          );\n          if (!techdocsMetadataJson) {\n            throw new Error(\n              `Unable to parse the techdocs metadata file ${entityRootDir}/techdocs_metadata.json.`,\n            );\n          }\n\n          const techdocsMetadata = JSON5.parse(\n            techdocsMetadataJson.toString('utf-8'),\n          );\n\n          resolve(techdocsMetadata);\n        } catch (err) {\n          assertError(err);\n          this.logger.error(err.message);\n          reject(new Error(err.message));\n        }\n      });\n    } catch (e) {\n      throw new ForwardedError('TechDocs metadata fetch failed', e);\n    }\n  }\n\n  /**\n   * Express route middleware to serve static files on a route in techdocs-backend.\n   */\n  docsRouter(): express.Handler {\n    return async (req, res) => {\n      const decodedUri = decodeURI(req.path.replace(/^\\//, ''));\n\n      // filePath example - /default/component/documented-component/index.html\n      const filePathNoRoot = this.legacyPathCasing\n        ? decodedUri\n        : lowerCaseEntityTripletInStoragePath(decodedUri);\n\n      // Prepend the root path to the relative file path\n      const filePath = path.posix.join(this.bucketRootPath, filePathNoRoot);\n      if (!isValidContentPath(this.bucketRootPath, filePath)) {\n        this.logger.error(\n          `Attempted to fetch TechDocs content for a file outside of the bucket root: ${filePathNoRoot}`,\n        );\n        res.status(404).send('File Not Found');\n        return;\n      }\n\n      // Files with different extensions (CSS, HTML) need to be served with different headers\n      const fileExtension = path.extname(filePath);\n      const responseHeaders = getHeadersForFileExtension(fileExtension);\n\n      try {\n        const resp = await this.storageClient.send(\n          new GetObjectCommand({ Bucket: this.bucketName, Key: filePath }),\n        );\n\n        // Inject response headers\n        for (const [headerKey, headerValue] of Object.entries(\n          responseHeaders,\n        )) {\n          res.setHeader(headerKey, headerValue);\n        }\n\n        (resp.Body as Readable)\n          .on('error', err => {\n            this.logger.warn(\n              `TechDocs S3 router failed to serve static files from bucket ${this.bucketName} at key ${filePath}: ${err.message}`,\n            );\n            if (!res.headersSent) {\n              res.status(404).send('File Not Found');\n            } else {\n              res.destroy();\n            }\n          })\n          .pipe(res);\n      } catch (err) {\n        assertError(err);\n        this.logger.warn(\n          `TechDocs S3 router failed to serve static files from bucket ${this.bucketName} at key ${filePath}: ${err.message}`,\n        );\n        res.status(404).send('File Not Found');\n      }\n    };\n  }\n\n  /**\n   * A helper function which checks if index.html of an Entity's docs site is available. This\n   * can be used to verify if there are any pre-generated docs available to serve.\n   */\n  async hasDocsBeenGenerated(entity: Entity): Promise<boolean> {\n    try {\n      const entityTriplet = `${entity.metadata.namespace}/${entity.kind}/${entity.metadata.name}`;\n      const entityDir = this.legacyPathCasing\n        ? entityTriplet\n        : lowerCaseEntityTriplet(entityTriplet);\n\n      const entityRootDir = path.posix.join(this.bucketRootPath, entityDir);\n      if (!isValidContentPath(this.bucketRootPath, entityRootDir)) {\n        this.logger.error(\n          `Invalid content path found while checking if docs have been generated: ${entityRootDir}`,\n        );\n        return Promise.resolve(false);\n      }\n\n      await this.storageClient.send(\n        new HeadObjectCommand({\n          Bucket: this.bucketName,\n          Key: `${entityRootDir}/index.html`,\n        }),\n      );\n      return Promise.resolve(true);\n    } catch (e) {\n      return Promise.resolve(false);\n    }\n  }\n\n  async migrateDocsCase({\n    removeOriginal = false,\n    concurrency = 25,\n  }): Promise<void> {\n    // Iterate through every file in the root of the publisher.\n    const allObjects = await this.getAllObjectsFromBucket();\n    const limiter = createLimiter(concurrency);\n    await Promise.all(\n      allObjects.map(f =>\n        limiter(async file => {\n          let newPath;\n          try {\n            newPath = lowerCaseEntityTripletInStoragePath(file);\n          } catch (e) {\n            assertError(e);\n            this.logger.warn(e.message);\n            return;\n          }\n\n          // If all parts are already lowercase, ignore.\n          if (file === newPath) {\n            return;\n          }\n\n          try {\n            this.logger.debug(`Migrating ${file}`);\n            await this.storageClient.send(\n              new CopyObjectCommand({\n                Bucket: this.bucketName,\n                CopySource: [this.bucketName, file].join('/'),\n                Key: newPath,\n              }),\n            );\n\n            if (removeOriginal) {\n              await this.storageClient.send(\n                new DeleteObjectCommand({\n                  Bucket: this.bucketName,\n                  Key: file,\n                }),\n              );\n            }\n          } catch (e) {\n            assertError(e);\n            this.logger.warn(`Unable to migrate ${file}: ${e.message}`);\n          }\n        }, f),\n      ),\n    );\n  }\n\n  /**\n   * Returns a list of all object keys from the configured bucket.\n   */\n  protected async getAllObjectsFromBucket(\n    { prefix } = { prefix: '' },\n  ): Promise<string[]> {\n    const objects: string[] = [];\n    let nextContinuation: string | undefined;\n    let allObjects: ListObjectsV2CommandOutput;\n    // Iterate through every file in the root of the publisher.\n    do {\n      const currentToken = nextContinuation;\n      allObjects = await this.retryOperation(\n        async () => {\n          const listCommand = new ListObjectsV2Command({\n            Bucket: this.bucketName,\n            ContinuationToken: currentToken,\n            ...(prefix ? { Prefix: prefix } : {}),\n          });\n          return this.storageClient.send(listCommand);\n        },\n        'GetAllObjects',\n        this.maxAttempts,\n      );\n      objects.push(\n        ...(allObjects.Contents || []).map(f => f.Key || '').filter(f => !!f),\n      );\n      nextContinuation = allObjects.NextContinuationToken;\n    } while (nextContinuation);\n\n    return objects;\n  }\n}\n"],"names":["ForwardedError","normalizeExternalStorageRootPath","DefaultAwsCredentialsManager","ScmIntegrations","S3Client","NodeHttpHandler","HttpsProxyAgent","fromTemporaryCredentials","HeadBucketCommand","getCloudPathForLocalPath","ListObjectsV2Command","assertError","getFileTreeRecursively","bulkStorageOperation","path","fs","Upload","PutObjectCommand","getStaleFiles","DeleteObjectCommand","lowerCaseEntityTriplet","isValidContentPath","GetObjectCommand","JSON5","lowerCaseEntityTripletInStoragePath","getHeadersForFileExtension","HeadObjectCommand","createLimiter","CopyObjectCommand"],"mappings":"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"}