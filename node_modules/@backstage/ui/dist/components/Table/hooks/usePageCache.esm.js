import { useState, useRef, useCallback, useEffect } from 'react';

const FIRST_PAGE_CURSOR = /* @__PURE__ */ Symbol("firstPage");
class PageCacheStore {
  cache = /* @__PURE__ */ new Map();
  get(cursor) {
    return this.cache.get(cursor);
  }
  getOrCreate(cursor) {
    const existing = this.cache.get(cursor);
    if (existing) {
      return existing;
    }
    const entry = {
      data: void 0,
      nextCursor: void 0,
      prevCursor: void 0
    };
    this.cache.set(cursor, entry);
    return entry;
  }
  clear() {
    this.cache.clear();
  }
  getTargetCursor(direction, currentCursor, initialCurrentCursor) {
    if (direction === "mount") {
      return toInternalCursor(initialCurrentCursor);
    }
    if (direction === "reset") {
      return FIRST_PAGE_CURSOR;
    }
    if (direction === "refresh") {
      return currentCursor;
    }
    const currentEntry = this.cache.get(currentCursor);
    if (!currentEntry) {
      return;
    }
    return direction === "next" ? currentEntry.nextCursor : currentEntry.prevCursor;
  }
  linkEntryToSource(entry, direction, currentCursor) {
    if (direction === "next") {
      entry.prevCursor = currentCursor;
    } else if (direction === "prev") {
      entry.nextCursor = currentCursor;
    }
  }
}
function toInternalCursor(cursor) {
  return cursor === void 0 ? FIRST_PAGE_CURSOR : cursor;
}
function toExternalCursor(cursor) {
  return cursor === FIRST_PAGE_CURSOR ? void 0 : cursor;
}
function usePageCache(options) {
  const { getData, initialCurrentCursor } = options;
  const [currentCursor, setCurrentCursor] = useState(
    () => toInternalCursor(initialCurrentCursor)
  );
  const cacheStore = useRef(new PageCacheStore()).current;
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(void 0);
  const [totalCount, setTotalCount] = useState(void 0);
  const abortControllerRef = useRef(null);
  const currentPage = cacheStore.get(currentCursor);
  const data = currentPage?.data;
  const hasNextPage = currentPage?.nextCursor !== void 0;
  const hasPreviousPage = currentPage?.prevCursor !== void 0;
  const goToPage = useCallback(
    async (direction) => {
      const targetCursor = cacheStore.getTargetCursor(
        direction,
        currentCursor,
        initialCurrentCursor
      );
      if (!targetCursor) {
        return;
      }
      const existingEntry = cacheStore.get(targetCursor);
      if (existingEntry?.data !== void 0) {
        setCurrentCursor(targetCursor);
        return;
      }
      const entry = cacheStore.getOrCreate(targetCursor);
      cacheStore.linkEntryToSource(entry, direction, currentCursor);
      setCurrentCursor(targetCursor);
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
      const abortController = new AbortController();
      abortControllerRef.current = abortController;
      setLoading(true);
      setError(void 0);
      try {
        const result = await getData({
          cursor: toExternalCursor(targetCursor),
          signal: abortController.signal
        });
        if (abortController.signal.aborted) {
          return;
        }
        entry.data = result.data;
        if (entry.nextCursor === void 0 && result.nextCursor !== void 0) {
          entry.nextCursor = result.nextCursor;
        }
        if (entry.prevCursor === void 0 && result.prevCursor !== void 0) {
          entry.prevCursor = result.prevCursor;
        }
        if (result.totalCount !== void 0) {
          setTotalCount(result.totalCount);
        }
        setLoading(false);
      } catch (err) {
        if (abortController.signal.aborted) {
          return;
        }
        setError(err instanceof Error ? err : new Error(String(err)));
        setLoading(false);
      }
    },
    [getData, initialCurrentCursor, currentCursor, cacheStore]
  );
  useEffect(() => {
    goToPage("mount");
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);
  const onNextPage = useCallback(() => {
    if (loading) return;
    const page = cacheStore.get(currentCursor);
    if (!page?.nextCursor) return;
    goToPage("next");
  }, [loading, currentCursor, goToPage, cacheStore]);
  const onPreviousPage = useCallback(() => {
    if (loading) return;
    const page = cacheStore.get(currentCursor);
    if (!page?.prevCursor) return;
    goToPage("prev");
  }, [loading, currentCursor, goToPage, cacheStore]);
  const reload = useCallback(
    (reloadOptions) => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
      cacheStore.clear();
      goToPage(reloadOptions?.keepCurrentCursor ? "refresh" : "reset");
    },
    [goToPage, cacheStore]
  );
  return {
    loading,
    error,
    data,
    totalCount,
    currentCursor: toExternalCursor(currentCursor),
    hasPreviousPage,
    onPreviousPage,
    hasNextPage,
    onNextPage,
    reload
  };
}

export { usePageCache };
//# sourceMappingURL=usePageCache.esm.js.map
