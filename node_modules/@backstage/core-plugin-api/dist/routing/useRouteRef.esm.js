import { useMemo } from 'react';
import { useLocation } from 'react-router-dom';
import { useVersionedContext } from '@backstage/version-bridge';
import { useApi, routeResolutionApiRef } from '@backstage/frontend-plugin-api';

function useRouteResolutionApi() {
  try {
    return useApi(routeResolutionApiRef);
  } catch {
    return void 0;
  }
}
function useRouteRef(routeRef) {
  const { pathname } = useLocation();
  const routeResolutionApi = useRouteResolutionApi();
  const versionedContext = useVersionedContext(
    "routing-context"
  );
  const resolver = versionedContext?.atVersion(1);
  const newRouteFunc = useMemo(() => {
    if (!routeResolutionApi) {
      return null;
    }
    try {
      return routeResolutionApi?.resolve(routeRef, {
        sourcePath: pathname
      });
    } catch {
      return null;
    }
  }, [routeResolutionApi, routeRef, pathname]);
  const legacyRouteFunc = useMemo(
    () => resolver && resolver.resolve(routeRef, { pathname }),
    [resolver, routeRef, pathname]
  );
  if (newRouteFunc !== null) {
    const isOptional2 = "optional" in routeRef && routeRef.optional;
    if (!newRouteFunc && !isOptional2) {
      throw new Error(`No path for ${routeRef}`);
    }
    return newRouteFunc;
  }
  if (!versionedContext) {
    throw new Error("Routing context is not available");
  }
  if (!resolver) {
    throw new Error("RoutingContext v1 not available");
  }
  const isOptional = "optional" in routeRef && routeRef.optional;
  if (!legacyRouteFunc && !isOptional) {
    throw new Error(`No path for ${routeRef}`);
  }
  return legacyRouteFunc;
}

export { useRouteRef };
//# sourceMappingURL=useRouteRef.esm.js.map
