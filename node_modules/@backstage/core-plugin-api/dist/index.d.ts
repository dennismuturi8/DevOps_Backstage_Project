import * as react_jsx_runtime from 'react/jsx-runtime';
import { ReactNode, ComponentType, PropsWithChildren, ReactElement } from 'react';
import { ApiRef, AnyApiFactory } from '@backstage/frontend-plugin-api';
export { AlertApi, AlertMessage, AnyApiFactory, AnyApiRef, ApiFactory, ApiHolder, ApiRef, ApiRefConfig, AppTheme, AppThemeApi, AuthProviderInfo, AuthRequestOptions, BackstageIdentityApi, BackstageIdentityResponse, BackstageUserIdentity, ConfigApi, DiscoveryApi, ErrorApi, ErrorApiError, ErrorApiErrorContext, FeatureFlag, FeatureFlagState, FeatureFlagsApi, FeatureFlagsSaveOptions, FetchApi, IconComponent, IdentityApi, OAuthApi, OAuthRequestApi, OAuthRequester, OAuthRequesterOptions, OAuthScope, OpenIdConnectApi, PendingOAuthRequest, ProfileInfo, ProfileInfoApi, SessionApi, SessionState, StorageApi, StorageValueSnapshot, TypesToApiRefs, alertApiRef, appThemeApiRef, atlassianAuthApiRef, bitbucketAuthApiRef, bitbucketServerAuthApiRef, configApiRef, createApiFactory, createApiRef, discoveryApiRef, errorApiRef, featureFlagsApiRef, fetchApiRef, githubAuthApiRef, gitlabAuthApiRef, googleAuthApiRef, identityApiRef, microsoftAuthApiRef, oauthRequestApiRef, oktaAuthApiRef, oneloginAuthApiRef, openshiftAuthApiRef, storageApiRef, useApi, useApiHolder, vmwareCloudAuthApiRef, withApis } from '@backstage/frontend-plugin-api';
import { BackstagePlugin as BackstagePlugin$1, IconComponent, IdentityApi } from '@backstage/core-plugin-api';

/**
 * Common analytics context attributes.
 *
 * @public
 */
type CommonAnalyticsContext = {
    /**
     * The nearest known parent plugin where the event was captured.
     */
    pluginId: string;
    /**
     * The ID of the routeRef that was active when the event was captured.
     */
    routeRef: string;
    /**
     * The nearest known parent extension where the event was captured.
     */
    extension: string;
};
/**
 * Analytics context envelope.
 *
 * @public
 */
type AnalyticsContextValue = CommonAnalyticsContext & {
    [param in string]: string | boolean | number | undefined;
};

/**
 * Provides components in the child react tree an Analytics Context, ensuring
 * all analytics events captured within the context have relevant attributes.
 *
 * @remarks
 *
 * Analytics contexts are additive, meaning the context ultimately emitted with
 * an event is the combination of all contexts in the parent tree.
 *
 * @public
 */
declare const AnalyticsContext: (options: {
    attributes: Partial<AnalyticsContextValue>;
    children: ReactNode;
}) => react_jsx_runtime.JSX.Element;

/**
 * Represents an event worth tracking in an analytics system that could inform
 * how users of a Backstage instance are using its features.
 *
 * @public
 */
type AnalyticsEvent = {
    /**
     * A string that identifies the event being tracked by the type of action the
     * event represents. Be careful not to encode extra metadata in this string
     * that should instead be placed in the Analytics Context or attributes.
     * Examples include:
     *
     * - view
     * - click
     * - filter
     * - search
     * - hover
     * - scroll
     */
    action: string;
    /**
     * A string that uniquely identifies the object that the action is being
     * taken on. Examples include:
     *
     * - The path of the page viewed
     * - The url of the link clicked
     * - The value that was filtered by
     * - The text that was searched for
     */
    subject: string;
    /**
     * An optional numeric value relevant to the event that could be aggregated
     * by analytics tools. Examples include:
     *
     * - The index or position of the clicked element in an ordered list
     * - The percentage of an element that has been scrolled through
     * - The amount of time that has elapsed since a fixed point
     * - A satisfaction score on a fixed scale
     */
    value?: number;
    /**
     * Optional, additional attributes (representing dimensions or metrics)
     * specific to the event that could be forwarded on to analytics systems.
     */
    attributes?: AnalyticsEventAttributes;
    /**
     * Contextual metadata relating to where the event was captured and by whom.
     * This could include information about the route, plugin, or extension in
     * which an event was captured.
     */
    context: AnalyticsContextValue;
};
/**
 * A structure allowing other arbitrary metadata to be provided by analytics
 * event emitters.
 *
 * @public
 */
type AnalyticsEventAttributes = {
    [attribute in string]: string | boolean | number;
};
/**
 * Represents a tracker with methods that can be called to track events in a
 * configured analytics service.
 *
 * @public
 */
type AnalyticsTracker = {
    captureEvent: (action: string, subject: string, options?: {
        value?: number;
        attributes?: AnalyticsEventAttributes;
    }) => void;
};
/**
 * The Analytics API is used to track user behavior in a Backstage instance.
 *
 * @remarks
 *
 * To instrument your App or Plugin, retrieve an analytics tracker using the
 * useAnalytics() hook. This will return a pre-configured AnalyticsTracker
 * with relevant methods for instrumentation.
 *
 * @public
 */
type AnalyticsApi = {
    /**
     * Primary event handler responsible for compiling and forwarding events to
     * an analytics system.
     */
    captureEvent(event: AnalyticsEvent): void;
};
/**
 * The `ApiRef` of {@link AnalyticsApi}.
 *
 * @public
 */
declare const analyticsApiRef: ApiRef<AnalyticsApi>;

/**
 * Gets a pre-configured analytics tracker.
 *
 * @public
 */
declare function useAnalytics(): AnalyticsTracker;

/**
 * Props for the `BootErrorPage` component of {@link AppComponents}.
 *
 * @public
 */
type BootErrorPageProps = PropsWithChildren<{
    step: 'load-config' | 'load-chunk';
    error: Error;
}>;
/**
 * Props for the `SignInPage` component of {@link AppComponents}.
 *
 * @public
 */
type SignInPageProps = PropsWithChildren<{
    /**
     * Set the IdentityApi on successful sign-in. This should only be called once.
     */
    onSignInSuccess(identityApi: IdentityApi): void;
}>;
/**
 * Props for the fallback error boundary.
 *
 * @public
 */
type ErrorBoundaryFallbackProps = PropsWithChildren<{
    plugin?: BackstagePlugin$1;
    error: Error;
    resetError: () => void;
}>;
/**
 * A set of replaceable core components that are part of every Backstage app.
 *
 * @public
 */
type AppComponents = {
    NotFoundErrorPage: ComponentType<PropsWithChildren<{}>>;
    BootErrorPage: ComponentType<BootErrorPageProps>;
    Progress: ComponentType<PropsWithChildren<{}>>;
    Router: ComponentType<PropsWithChildren<{
        basename?: string;
    }>>;
    ErrorBoundaryFallback: ComponentType<ErrorBoundaryFallbackProps>;
    ThemeProvider?: ComponentType<PropsWithChildren<{}>>;
    /**
     * An optional sign-in page that will be rendered instead of the AppRouter at startup.
     *
     * If a sign-in page is set, it will always be shown before the app, and it is up
     * to the sign-in page to handle e.g. saving of login methods for subsequent visits.
     *
     * The sign-in page will be displayed until it has passed up a result to the parent,
     * and which point the AppRouter and all of its children will be rendered instead.
     */
    SignInPage?: ComponentType<SignInPageProps>;
};
/**
 * The central context providing runtime app specific state that plugin views
 * want to consume.
 *
 * @public
 */
type AppContext = {
    /**
     * Get a list of all plugins that are installed in the app.
     */
    getPlugins(): BackstagePlugin$1[];
    /**
     * Get a common or custom icon for this app.
     */
    getSystemIcon(key: string): IconComponent | undefined;
    /**
     * Get a list of common and custom icons for this app.
     */
    getSystemIcons(): Record<string, IconComponent>;
    /**
     * Get the components registered for various purposes in the app.
     */
    getComponents(): AppComponents;
};

/**
 * React hook providing {@link AppContext}.
 *
 * @public
 */
declare const useApp: () => AppContext;

/**
 * Stores data related to a component in a global store.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#component-data}.
 *
 * @param component - The component to attach the data to.
 * @param type - The key under which the data will be stored.
 * @param data - Arbitrary value.
 * @public
 */
declare function attachComponentData<P>(component: ComponentType<P>, type: string, data: unknown): void;
/**
 * Retrieves data attached to a component.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#component-data}.
 *
 * @param node - React component to look up.
 * @param type - Key of the data to retrieve.
 * @returns Data stored using {@link attachComponentData}.
 * @public
 */
declare function getComponentData<T>(node: ReactNode, type: string): T | undefined;

/**
 * Catch-all type for route params.
 *
 * @public
 */
type AnyRouteRefParams = {
    [param in string]: string;
} | undefined;
/**
 * @deprecated use {@link AnyRouteRefParams} instead
 * @public
 */
type AnyParams = AnyRouteRefParams;
/**
 * Type describing the key type of a route parameter mapping.
 *
 * @public
 * @deprecated this type is deprecated and will be removed in the future
 */
type ParamKeys<Params extends AnyParams> = [AnyRouteRefParams] extends [
    Params
] ? string[] : keyof Params extends never ? [] : Array<keyof Params>;
/**
 * Optional route params.
 *
 * @public
 * @deprecated this type is deprecated and will be removed in the future
 */
type OptionalParams<Params extends {
    [param in string]: string;
}> = Params[keyof Params] extends never ? undefined : Params;
/**
 * TS magic for handling route parameters.
 *
 * @remarks
 *
 * The extra TS magic here is to require a single params argument if the RouteRef
 * had at least one param defined, but require 0 arguments if there are no params defined.
 * Without this we'd have to pass in empty object to all parameter-less RouteRefs
 * just to make TypeScript happy, or we would have to make the argument optional in
 * which case you might forget to pass it in when it is actually required.
 *
 * @public
 */
type RouteFunc<Params extends AnyParams> = (...[params]: Params extends undefined ? readonly [] : readonly [Params]) => string;
/**
 * Absolute route reference.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
type RouteRef<Params extends AnyParams = any> = {
    /** @deprecated access to this property will be removed in the future */
    $$routeRefType: 'absolute';
    /** @deprecated access to this property will be removed in the future */
    params: ParamKeys<Params>;
    /** Compatibility field for new frontend system */
    readonly $$type: '@backstage/RouteRef';
    /** Compatibility field for new frontend system */
    readonly T: Params;
};
/**
 * Descriptor of a route relative to an absolute {@link RouteRef}.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
type SubRouteRef<Params extends AnyParams = any> = {
    /** @deprecated access to this property will be removed in the future */
    $$routeRefType: 'sub';
    /** @deprecated access to this property will be removed in the future */
    parent: RouteRef;
    path: string;
    /** @deprecated access to this property will be removed in the future */
    params: ParamKeys<Params>;
    /** Compatibility field for new frontend system */
    readonly $$type: '@backstage/SubRouteRef';
    /** Compatibility field for new frontend system */
    readonly T: Params;
};
/**
 * Route descriptor, to be later bound to a concrete route by the app. Used to implement cross-plugin route references.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
type ExternalRouteRef<Params extends AnyParams = any, Optional extends boolean = any> = {
    /** @deprecated access to this property will be removed in the future */
    $$routeRefType: 'external';
    /** @deprecated access to this property will be removed in the future */
    params: ParamKeys<Params>;
    optional?: Optional;
    /** Compatibility field for new frontend system */
    readonly $$type: '@backstage/ExternalRouteRef';
    /** Compatibility field for new frontend system */
    readonly T: Params;
};

/**
 * Create a {@link RouteRef} from a route descriptor.
 *
 * @param config - Description of the route reference to be created.
 * @public
 */
declare function createRouteRef<Params extends {
    [param in ParamKey]: string;
}, ParamKey extends string = never>(config: {
    /** The id of the route ref, used to identify it when printed */
    id: string;
    /** A list of parameter names that the path that this route ref is bound to must contain */
    params?: ParamKey[];
}): RouteRef<OptionalParams<Params>>;

/**
 * Used in {@link PathParams} type declaration.
 * @public
 * @deprecated this type is deprecated and will be removed in the future
 */
type ParamPart<S extends string> = S extends `:${infer Param}` ? Param : never;
/**
 * Used in {@link PathParams} type declaration.
 * @public
 * @deprecated this type is deprecated and will be removed in the future
 */
type ParamNames<S extends string> = S extends `${infer Part}/${infer Rest}` ? ParamPart<Part> | ParamNames<Rest> : ParamPart<S>;
/**
 * This utility type helps us infer a Param object type from a string path
 * For example, `/foo/:bar/:baz` inferred to `{ bar: string, baz: string }`
 * @public
 * @deprecated this type is deprecated and will be removed in the future
 */
type PathParams<S extends string> = {
    [name in ParamNames<S>]: string;
};
/**
 * Merges a param object type with an optional params type into a params object.
 * @public
 * @deprecated this type is deprecated and will be removed in the future
 */
type MergeParams<P1 extends {
    [param in string]: string;
}, P2 extends AnyParams> = (P1[keyof P1] extends never ? {} : P1) & (P2 extends undefined ? {} : P2);
/**
 * Creates a SubRouteRef type given the desired parameters and parent route parameters.
 * The parameters types are merged together while ensuring that there is no overlap between the two.
 *
 * @public
 * @deprecated this type is deprecated and will be removed in the future
 */
type MakeSubRouteRef<Params extends {
    [param in string]: string;
}, ParentParams extends AnyParams> = keyof Params & keyof ParentParams extends never ? SubRouteRef<OptionalParams<MergeParams<Params, ParentParams>>> : never;
/**
 * Create a {@link SubRouteRef} from a route descriptor.
 *
 * @param config - Description of the route reference to be created.
 * @public
 */
declare function createSubRouteRef<Path extends string, ParentParams extends AnyParams = never>(config: {
    id: string;
    path: Path;
    parent: RouteRef<ParentParams>;
}): MakeSubRouteRef<PathParams<Path>, ParentParams>;

/**
 * Creates a route descriptor, to be later bound to a concrete route by the app. Used to implement cross-plugin route references.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @param options - Description of the route reference to be created.
 * @public
 */
declare function createExternalRouteRef<Params extends {
    [param in ParamKey]: string;
}, Optional extends boolean = false, ParamKey extends string = never>(options: {
    /**
     * An identifier for this route, used to identify it in error messages
     */
    id: string;
    /**
     * The parameters that will be provided to the external route reference.
     */
    params?: ParamKey[];
    /**
     * Whether or not this route is optional, defaults to false.
     *
     * Optional external routes are not required to be bound in the app, and
     * if they aren't, `useRouteRef` will return `undefined`.
     */
    optional?: Optional;
    /**
     * The route (typically in another plugin) that this should map to by default.
     *
     * The string is expected to be on the standard `<plugin id>.<route id>` form,
     * for example `techdocs.docRoot`.
     */
    defaultTarget?: string;
}): ExternalRouteRef<OptionalParams<Params>, Optional>;

/**
 * React hook for constructing URLs to routes.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}
 *
 * @param routeRef - The ref to route that should be converted to URL.
 * @returns A function that will in turn return the concrete URL of the `routeRef`.
 * @public
 */
declare function useRouteRef<Optional extends boolean, Params extends AnyParams>(routeRef: ExternalRouteRef<Params, Optional>): Optional extends true ? RouteFunc<Params> | undefined : RouteFunc<Params>;
/**
 * React hook for constructing URLs to routes.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}
 *
 * @param routeRef - The ref to route that should be converted to URL.
 * @returns A function that will in turn return the concrete URL of the `routeRef`.
 * @public
 */
declare function useRouteRef<Params extends AnyParams>(routeRef: RouteRef<Params> | SubRouteRef<Params>): RouteFunc<Params>;

/**
 * React hook for retrieving dynamic params from the current URL.
 * @param _routeRef - Ref of the current route.
 * @public
 */
declare function useRouteRefParams<Params extends AnyParams>(_routeRef: RouteRef<Params> | SubRouteRef<Params>): Params;

/**
 * Plugin extension type.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#extensions}.
 *
 * @public
 */
type Extension<T> = {
    expose(plugin: BackstagePlugin): T;
};
/**
 * Catch-all route type.
 *
 * @public
 */
type AnyRoutes = {
    [name: string]: RouteRef | SubRouteRef;
};
/**
 * Catch-all type for {@link ExternalRouteRef}s.
 *
 * @public
 */
type AnyExternalRoutes = {
    [name: string]: ExternalRouteRef;
};
/**
 * Plugin type.
 *
 * @public
 */
type BackstagePlugin<Routes extends AnyRoutes = {}, ExternalRoutes extends AnyExternalRoutes = {}, _Ignored extends {} = {}> = {
    getId(): string;
    getApis(): Iterable<AnyApiFactory>;
    /**
     * Returns all registered feature flags for this plugin.
     */
    getFeatureFlags(): Iterable<PluginFeatureFlagConfig>;
    provide<T>(extension: Extension<T>): T;
    routes: Routes;
    externalRoutes: ExternalRoutes;
};
/**
 * Plugin feature flag configuration.
 *
 * @public
 */
type PluginFeatureFlagConfig = {
    /** Feature flag name */
    name: string;
};
/**
 * Plugin descriptor type.
 *
 * @public
 */
type PluginConfig<Routes extends AnyRoutes, ExternalRoutes extends AnyExternalRoutes> = {
    id: string;
    apis?: Iterable<AnyApiFactory>;
    routes?: Routes;
    externalRoutes?: ExternalRoutes;
    featureFlags?: PluginFeatureFlagConfig[];
};
/**
 * Interface for registering feature flags hooks.
 *
 * @public
 */
type FeatureFlagsHooks = {
    register(name: string): void;
};

/**
 * Creates Backstage Plugin from config.
 *
 * @param config - Plugin configuration.
 * @public
 */
declare function createPlugin<Routes extends AnyRoutes = {}, ExternalRoutes extends AnyExternalRoutes = {}>(config: PluginConfig<Routes, ExternalRoutes>): BackstagePlugin<Routes, ExternalRoutes>;

/**
 * Lazy or synchronous retrieving of extension components.
 *
 * @public
 */
type ComponentLoader<T> = {
    lazy: () => Promise<T>;
} | {
    sync: T;
};
/**
 * Extension for components that can have its own URL route (top-level pages, tabs etc.).
 *
 * @remarks
 *
 * We do not use ComponentType as the return type, since it doesn't let us convey the children prop.
 * ComponentType inserts children as an optional prop whether the inner component accepts it or not,
 * making it impossible to make the usage of children type safe.
 *
 * See {@link https://backstage.io/docs/plugins/composability#extensions}.
 *
 * @public
 */
declare function createRoutableExtension<T extends (props: any) => JSX.Element | null>(options: {
    /**
     * A loader for the component that is rendered by this extension.
     */
    component: () => Promise<T>;
    /**
     * The mount point to bind this routable extension to.
     *
     * If this extension is placed somewhere in the app element tree of a Backstage
     * app, callers will be able to route to this extensions by calling,
     * `useRouteRef` with this mount point.
     */
    mountPoint: RouteRef;
    /**
     * The name of this extension that will represent it at runtime. It is for example
     * used to identify this extension in analytics data.
     *
     * If possible the name should always be the same as the name of the exported
     * variable for this extension.
     */
    name?: string;
}): Extension<T>;
/**
 * Plain React component extension.
 *
 * @remarks
 *
 * We do not use ComponentType as the return type, since it doesn't let us convey the children prop.
 * ComponentType inserts children as an optional prop whether the inner component accepts it or not,
 * making it impossible to make the usage of children type safe.
 *
 * See {@link https://backstage.io/docs/plugins/composability#extensions}.
 *
 * @public
 */
declare function createComponentExtension<T extends (props: any) => JSX.Element | null>(options: {
    /**
     * A loader or synchronously supplied component that is rendered by this extension.
     */
    component: ComponentLoader<T>;
    /**
     * The name of this extension that will represent it at runtime. It is for example
     * used to identify this extension in analytics data.
     *
     * If possible the name should always be the same as the name of the exported
     * variable for this extension.
     */
    name?: string;
}): Extension<T>;
/**
 * Used by {@link createComponentExtension} and {@link createRoutableExtension}.
 *
 * @remarks
 *
 * We do not use ComponentType as the return type, since it doesn't let us convey the children prop.
 * ComponentType inserts children as an optional prop whether the inner component accepts it or not,
 * making it impossible to make the usage of children type safe.
 *
 * See {@link https://backstage.io/docs/plugins/composability#extensions}.
 *
 * @public
 */
declare function createReactExtension<T extends (props: any) => JSX.Element | null>(options: {
    /**
     * A loader or synchronously supplied component that is rendered by this extension.
     */
    component: ComponentLoader<T>;
    /**
     * Additional component data that is attached to the top-level extension component.
     */
    data?: Record<string, unknown>;
    /**
     * The name of this extension that will represent it at runtime. It is for example
     * used to identify this extension in analytics data.
     *
     * If possible the name should always be the same as the name of the exported
     * variable for this extension.
     */
    name?: string;
}): Extension<T>;

/**
 * A querying interface tailored to traversing a set of selected React elements
 * and extracting data.
 *
 * @remarks
 *
 * Methods prefixed with `selectBy` are used to narrow the set of selected elements.
 *
 * Methods prefixed with `find` return concrete data using a deep traversal of the set.
 *
 * Methods prefixed with `get` return concrete data using a shallow traversal of the set.
 *
 * @public
 */
interface ElementCollection {
    /**
     * Narrows the set of selected components by doing a deep traversal and
     * only including those that have defined component data for the given `key`.
     *
     * @remarks
     *
     * Whether an element in the tree has component data set for the given key
     * is determined by whether `getComponentData` returns undefined.
     *
     * The traversal does not continue deeper past elements that match the criteria,
     * and it also includes the root children in the selection, meaning that if the,
     * of all the currently selected elements contain data for the given key, this
     * method is a no-op.
     *
     * If `withStrictError` is set, the resulting selection must be a full match, meaning
     * there may be no elements that were excluded in the selection. If the selection
     * is not a clean match, an error will be throw with `withStrictError` as the message.
     *
     * @param query - Filtering query.
     */
    selectByComponentData(query: {
        key: string;
        withStrictError?: string;
    }): ElementCollection;
    /**
     * Finds all elements using the same criteria as `selectByComponentData`, but
     * returns the actual component data of each of those elements instead.
     *
     * @param query - Lookup query.
     */
    findComponentData<T>(query: {
        key: string;
    }): T[];
    /**
     * Returns all of the elements currently selected by this collection.
     */
    getElements<Props extends {
        [name: string]: unknown;
    }>(): Array<ReactElement<Props>>;
}
/**
 * useElementFilter is a utility that helps you narrow down and retrieve data
 * from a React element tree, typically operating on the `children` property
 * passed in to a component.
 *
 * @remarks
 *
 * A common use-case is to construct declarative APIs
 * where a React component defines its behavior based on its children, such as
 * the relationship between `Routes` and `Route` in `react-router`.
 *
 * The purpose of this hook is similar to `React.Children.map`, and it expands upon
 * it to also handle traversal of fragments and Backstage specific things like the
 * `FeatureFlagged` component.
 *
 * The return value of the hook is computed by the provided filter function, but
 * with added memoization based on the input `node`. If further memoization
 * dependencies are used in the filter function, they should be added to the
 * third `dependencies` argument, just like `useMemo`, `useEffect`, etc.
 *
 * @public
 */
declare function useElementFilter<T>(node: ReactNode, filterFn: (arg: ElementCollection) => T, dependencies?: any[]): T;

export { AnalyticsContext, analyticsApiRef, attachComponentData, createComponentExtension, createExternalRouteRef, createPlugin, createReactExtension, createRoutableExtension, createRouteRef, createSubRouteRef, getComponentData, useAnalytics, useApp, useElementFilter, useRouteRef, useRouteRefParams };
export type { AnalyticsApi, AnalyticsContextValue, AnalyticsEvent, AnalyticsEventAttributes, AnalyticsTracker, AnyExternalRoutes, AnyParams, AnyRouteRefParams, AnyRoutes, AppComponents, AppContext, BackstagePlugin, BootErrorPageProps, CommonAnalyticsContext, ComponentLoader, ElementCollection, ErrorBoundaryFallbackProps, Extension, ExternalRouteRef, FeatureFlagsHooks, MakeSubRouteRef, MergeParams, OptionalParams, ParamKeys, ParamNames, ParamPart, PathParams, PluginConfig, PluginFeatureFlagConfig, RouteFunc, RouteRef, SignInPageProps, SubRouteRef };
