"use strict";
/**
 * The following code is modified based on
 * https://github.com/webpack/webpack-dev-server
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack-dev-server/blob/main/LICENSE
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const os = __importStar(require("node:os"));
const path = __importStar(require("node:path"));
const url = __importStar(require("node:url"));
const util = __importStar(require("node:util"));
const fs = __importStar(require("graceful-fs"));
const ipaddr = __importStar(require("ipaddr.js"));
const schema_utils_1 = require("schema-utils");
const options_json_1 = __importDefault(require("./options.json"));
// Define BasicApplication and Server as ambient, or import them
if (!process.env.WEBPACK_SERVE) {
    process.env.WEBPACK_SERVE = 'true';
}
const memoize = (fn) => {
    let cache = false;
    let result;
    let fnRef = fn;
    return () => {
        if (cache) {
            return result;
        }
        result = fnRef();
        cache = true;
        // Allow to clean up memory for fn and all dependent resources
        fnRef = undefined;
        return result;
    };
};
const getExpress = memoize(() => require('express'));
const encodeOverlaySettings = (setting) => {
    return typeof setting === 'function'
        ? encodeURIComponent(setting.toString())
        : setting;
};
const DEFAULT_ALLOWED_PROTOCOLS = /^(file|.+-extension):/i;
function isMultiCompiler(compiler) {
    return Array.isArray(compiler.compilers);
}
class Server {
    constructor(options, compiler) {
        this.isTlsServer = false;
        (0, schema_utils_1.validate)(options_json_1.default, options, {
            name: 'Dev Server',
            baseDataPath: 'options',
        });
        this.compiler = compiler;
        this.logger = this.compiler.getInfrastructureLogger('webpack-dev-server');
        this.options = options;
        this.staticWatchers = [];
        this.listeners = [];
        this.webSocketProxies = [];
        this.sockets = [];
        this.currentHash = undefined;
    }
    static get schema() {
        return options_json_1.default;
    }
    static get DEFAULT_STATS() {
        return {
            all: false,
            hash: true,
            warnings: true,
            errors: true,
            errorDetails: false,
        };
    }
    static isAbsoluteURL(URL) {
        // Don't match Windows paths `c:\`
        if (/^[a-zA-Z]:\\/.test(URL)) {
            return false;
        }
        // Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
        // Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
        return /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(URL);
    }
    static findIp(gatewayOrFamily, isInternal) {
        if (gatewayOrFamily === 'v4' || gatewayOrFamily === 'v6') {
            let host;
            const networks = Object.values(os.networkInterfaces())
                .flatMap((networks) => networks ?? [])
                .filter((network) => {
                if (!network || !network.address) {
                    return false;
                }
                if (network.family !== `IP${gatewayOrFamily}`) {
                    return false;
                }
                if (typeof isInternal !== 'undefined' &&
                    network.internal !== isInternal) {
                    return false;
                }
                if (gatewayOrFamily === 'v6') {
                    const range = ipaddr.parse(network.address).range();
                    if (range !== 'ipv4Mapped' &&
                        range !== 'uniqueLocal' &&
                        range !== 'loopback') {
                        return false;
                    }
                }
                return network.address;
            });
            if (networks.length > 0) {
                // Take the first network found
                host = networks[0].address;
                if (host.includes(':')) {
                    host = `[${host}]`;
                }
            }
            return host;
        }
        const gatewayIp = ipaddr.parse(gatewayOrFamily);
        // Look for the matching interface in all local interfaces.
        for (const addresses of Object.values(os.networkInterfaces())) {
            for (const { cidr } of addresses) {
                const net = ipaddr.parseCIDR(cidr);
                if (net[0] &&
                    net[0].kind() === gatewayIp.kind() &&
                    gatewayIp.match(net)) {
                    return net[0].toString();
                }
            }
        }
    }
    // TODO remove me in the next major release, we have `findIp`
    static async internalIP(family) {
        return Server.findIp(family, false);
    }
    // TODO remove me in the next major release, we have `findIp`
    static internalIPSync(family) {
        return Server.findIp(family, false);
    }
    static async getHostname(hostname) {
        if (hostname === 'local-ip') {
            return (Server.findIp('v4', false) || Server.findIp('v6', false) || '0.0.0.0');
        }
        if (hostname === 'local-ipv4') {
            return Server.findIp('v4', false) || '0.0.0.0';
        }
        if (hostname === 'local-ipv6') {
            return Server.findIp('v6', false) || '::';
        }
        return hostname;
    }
    static async getFreePort(port, host) {
        if (typeof port !== 'undefined' && port !== null && port !== 'auto') {
            return port;
        }
        const { default: pRetry } = await import('p-retry');
        const getPort = require('./getPort');
        const basePort = typeof process.env.WEBPACK_DEV_SERVER_BASE_PORT !== 'undefined'
            ? Number.parseInt(process.env.WEBPACK_DEV_SERVER_BASE_PORT, 10)
            : 8080;
        // Try to find unused port and listen on it for 3 times,
        // if port is not specified in options.
        const defaultPortRetry = typeof process.env.WEBPACK_DEV_SERVER_PORT_RETRY !== 'undefined'
            ? Number.parseInt(process.env.WEBPACK_DEV_SERVER_PORT_RETRY, 10)
            : 3;
        return pRetry(() => getPort(basePort, host), {
            retries: defaultPortRetry,
        });
    }
    static findCacheDir() {
        const cwd = process.cwd();
        let dir = cwd;
        for (;;) {
            try {
                if (fs.statSync(path.join(dir, 'package.json')).isFile())
                    break;
                // eslint-disable-next-line no-empty
            }
            catch { }
            const parent = path.dirname(dir);
            if (dir === parent) {
                dir = undefined;
                break;
            }
            dir = parent;
        }
        if (!dir) {
            return path.resolve(cwd, '.cache/webpack-dev-server');
        }
        if (process.versions.pnp === '1') {
            return path.resolve(dir, '.pnp/.cache/webpack-dev-server');
        }
        if (process.versions.pnp === '3') {
            return path.resolve(dir, '.yarn/.cache/webpack-dev-server');
        }
        return path.resolve(dir, 'node_modules/.cache/webpack-dev-server');
    }
    static isWebTarget(compiler) {
        if (compiler.platform?.web) {
            return compiler.platform.web;
        }
        // TODO improve for the next major version and keep only `webTargets` to fallback for old versions
        if (compiler.options.externalsPresets?.web) {
            return true;
        }
        if (compiler.options.resolve?.conditionNames?.includes('browser')) {
            return true;
        }
        const webTargets = [
            'web',
            'webworker',
            'electron-preload',
            'electron-renderer',
            'nwjs',
            'node-webkit',
            undefined,
            null,
        ];
        if (Array.isArray(compiler.options.target)) {
            return compiler.options.target.some((r) => webTargets.includes(r));
        }
        return webTargets.includes(compiler.options.target);
    }
    addAdditionalEntries(compiler) {
        const additionalEntries = [];
        const isWebTarget = Server.isWebTarget(compiler);
        // TODO maybe empty client
        if (this.options.client && isWebTarget) {
            let webSocketURLStr = '';
            if (this.options.webSocketServer) {
                const webSocketURL = this.options.client
                    .webSocketURL;
                const webSocketServer = this.options.webSocketServer;
                const searchParams = new URLSearchParams();
                let protocol;
                // We are proxying dev server and need to specify custom `hostname`
                if (typeof webSocketURL.protocol !== 'undefined') {
                    protocol = webSocketURL.protocol;
                }
                else {
                    protocol = this.isTlsServer ? 'wss:' : 'ws:';
                }
                searchParams.set('protocol', protocol);
                if (typeof webSocketURL.username !== 'undefined') {
                    searchParams.set('username', webSocketURL.username);
                }
                if (typeof webSocketURL.password !== 'undefined') {
                    searchParams.set('password', webSocketURL.password);
                }
                let hostname;
                // SockJS is not supported server mode, so `hostname` and `port` can't specified, let's ignore them
                const isSockJSType = webSocketServer.type === 'sockjs';
                const isWebSocketServerHostDefined = typeof webSocketServer.options.host !== 'undefined';
                const isWebSocketServerPortDefined = typeof webSocketServer.options.port !== 'undefined';
                if (isSockJSType &&
                    (isWebSocketServerHostDefined || isWebSocketServerPortDefined)) {
                    this.logger.warn("SockJS only supports client mode and does not support custom hostname and port options. Please consider using 'ws' if you need to customize these options.");
                }
                // We are proxying dev server and need to specify custom `hostname`
                if (typeof webSocketURL.hostname !== 'undefined') {
                    hostname = webSocketURL.hostname;
                }
                // Web socket server works on custom `hostname`, only for `ws` because `sock-js` is not support custom `hostname`
                else if (isWebSocketServerHostDefined && !isSockJSType) {
                    hostname = webSocketServer.options.host;
                }
                // The `host` option is specified
                else if (typeof this.options.host !== 'undefined') {
                    hostname = this.options.host;
                }
                // The `port` option is not specified
                else {
                    hostname = '0.0.0.0';
                }
                searchParams.set('hostname', hostname);
                let port;
                // We are proxying dev server and need to specify custom `port`
                if (typeof webSocketURL.port !== 'undefined') {
                    port = webSocketURL.port;
                }
                // Web socket server works on custom `port`, only for `ws` because `sock-js` is not support custom `port`
                else if (isWebSocketServerPortDefined && !isSockJSType) {
                    port = webSocketServer.options.port;
                }
                // The `port` option is specified
                else if (typeof this.options.port === 'number') {
                    port = this.options.port;
                }
                // The `port` option is specified using `string`
                else if (typeof this.options.port === 'string' &&
                    this.options.port !== 'auto') {
                    port = Number(this.options.port);
                }
                // The `port` option is not specified or set to `auto`
                else {
                    port = '0';
                }
                searchParams.set('port', String(port));
                let pathname = '';
                // We are proxying dev server and need to specify custom `pathname`
                if (typeof webSocketURL.pathname !== 'undefined') {
                    pathname = webSocketURL.pathname;
                }
                // Web socket server works on custom `path`
                else if (typeof webSocketServer.options.prefix !== 'undefined' ||
                    typeof webSocketServer.options.path !== 'undefined') {
                    pathname =
                        webSocketServer.options.prefix || webSocketServer.options.path;
                }
                searchParams.set('pathname', pathname);
                const client = this.options.client;
                if (typeof client.logging !== 'undefined') {
                    searchParams.set('logging', client.logging);
                }
                if (typeof client.progress !== 'undefined') {
                    searchParams.set('progress', String(client.progress));
                }
                if (typeof client.overlay !== 'undefined') {
                    const overlayString = typeof client.overlay === 'boolean'
                        ? String(client.overlay)
                        : JSON.stringify({
                            ...client.overlay,
                            errors: encodeOverlaySettings(client.overlay.errors),
                            warnings: encodeOverlaySettings(client.overlay.warnings),
                            runtimeErrors: encodeOverlaySettings(client.overlay.runtimeErrors),
                        });
                    searchParams.set('overlay', overlayString);
                }
                if (typeof client.reconnect !== 'undefined') {
                    searchParams.set('reconnect', typeof client.reconnect === 'number'
                        ? String(client.reconnect)
                        : '10');
                }
                if (typeof this.options.hot !== 'undefined') {
                    searchParams.set('hot', String(this.options.hot));
                }
                if (typeof this.options.liveReload !== 'undefined') {
                    searchParams.set('live-reload', String(this.options.liveReload));
                }
                webSocketURLStr = searchParams.toString();
            }
            additionalEntries.push(`${this.getClientEntry()}?${webSocketURLStr}`);
        }
        const clientHotEntry = this.getClientHotEntry();
        if (clientHotEntry) {
            additionalEntries.push(clientHotEntry);
        }
        const webpack = compiler.webpack || require('webpack');
        // use a hook to add entries if available
        for (const additionalEntry of additionalEntries) {
            new webpack.EntryPlugin(compiler.context, additionalEntry, {
                name: undefined,
            }).apply(compiler);
        }
    }
    /**
     * @private
     * @returns {Compiler["options"]} compiler options
     */
    getCompilerOptions() {
        if (typeof this.compiler.compilers !== 'undefined') {
            if (this.compiler.compilers.length === 1) {
                return this.compiler.compilers[0].options;
            }
            // Configuration with the `devServer` options
            const compilerWithDevServer = this.compiler.compilers.find((config) => config.options.devServer);
            if (compilerWithDevServer) {
                return compilerWithDevServer.options;
            }
            // Configuration with `web` preset
            const compilerWithWebPreset = this.compiler.compilers.find((config) => config.options.externalsPresets?.web ||
                [
                    'web',
                    'webworker',
                    'electron-preload',
                    'electron-renderer',
                    'node-webkit',
                    undefined,
                    null,
                ].includes(config.options.target));
            if (compilerWithWebPreset) {
                return compilerWithWebPreset.options;
            }
            // Fallback
            return this.compiler.compilers[0].options;
        }
        return this.compiler.options;
    }
    async normalizeOptions() {
        const { options } = this;
        const compilerOptions = this.getCompilerOptions();
        const compilerWatchOptions = compilerOptions.watchOptions;
        const getWatchOptions = (watchOptions = {}) => {
            const getPolling = () => {
                if (typeof watchOptions.usePolling !== 'undefined') {
                    return watchOptions.usePolling;
                }
                if (typeof watchOptions.poll !== 'undefined') {
                    return Boolean(watchOptions.poll);
                }
                if (typeof compilerWatchOptions.poll !== 'undefined') {
                    return Boolean(compilerWatchOptions.poll);
                }
                return false;
            };
            const getInterval = () => {
                if (typeof watchOptions.interval !== 'undefined') {
                    return watchOptions.interval;
                }
                if (typeof watchOptions.poll === 'number') {
                    return watchOptions.poll;
                }
                if (typeof compilerWatchOptions.poll === 'number') {
                    return compilerWatchOptions.poll;
                }
            };
            const usePolling = getPolling();
            const interval = getInterval();
            const { poll, ...rest } = watchOptions;
            return {
                ignoreInitial: true,
                persistent: true,
                followSymlinks: false,
                atomic: false,
                alwaysStat: true,
                ignorePermissionErrors: true,
                // Respect options from compiler watchOptions
                usePolling,
                interval,
                ignored: watchOptions.ignored,
                // TODO: we respect these options for all watch options and allow developers to pass them to chokidar, but chokidar doesn't have these options maybe we need revisit that in future
                ...rest,
            };
        };
        const getStaticItem = (optionsForStatic) => {
            const getDefaultStaticOptions = () => {
                return {
                    directory: path.join(process.cwd(), 'public'),
                    staticOptions: {},
                    publicPath: ['/'],
                    serveIndex: { icons: true },
                    watch: getWatchOptions(),
                };
            };
            let item;
            if (typeof optionsForStatic === 'undefined') {
                item = getDefaultStaticOptions();
            }
            else if (typeof optionsForStatic === 'string') {
                item = {
                    ...getDefaultStaticOptions(),
                    directory: optionsForStatic,
                };
            }
            else {
                const def = getDefaultStaticOptions();
                item = {
                    directory: typeof optionsForStatic.directory !== 'undefined'
                        ? optionsForStatic.directory
                        : def.directory,
                    staticOptions: typeof optionsForStatic.staticOptions !== 'undefined'
                        ? { ...def.staticOptions, ...optionsForStatic.staticOptions }
                        : def.staticOptions,
                    publicPath: 
                    // eslint-disable-next-line no-nested-ternary
                    typeof optionsForStatic.publicPath !== 'undefined'
                        ? Array.isArray(optionsForStatic.publicPath)
                            ? optionsForStatic.publicPath
                            : [optionsForStatic.publicPath]
                        : def.publicPath,
                    serveIndex: 
                    // Check if 'serveIndex' property is defined in 'optionsForStatic'
                    // If 'serveIndex' is a boolean and true, use default 'serveIndex'
                    // If 'serveIndex' is an object, merge its properties with default 'serveIndex'
                    // If 'serveIndex' is neither a boolean true nor an object, use it as-is
                    // If 'serveIndex' is not defined in 'optionsForStatic', use default 'serveIndex'
                    // eslint-disable-next-line no-nested-ternary
                    typeof optionsForStatic.serveIndex !== 'undefined'
                        ? // eslint-disable-next-line no-nested-ternary
                            typeof optionsForStatic.serveIndex === 'boolean' &&
                                optionsForStatic.serveIndex
                                ? def.serveIndex
                                : typeof optionsForStatic.serveIndex === 'object'
                                    ? { ...def.serveIndex, ...optionsForStatic.serveIndex }
                                    : optionsForStatic.serveIndex
                        : def.serveIndex,
                    watch: 
                    // eslint-disable-next-line no-nested-ternary
                    typeof optionsForStatic.watch !== 'undefined'
                        ? // eslint-disable-next-line no-nested-ternary
                            typeof optionsForStatic.watch === 'boolean'
                                ? optionsForStatic.watch
                                    ? def.watch
                                    : false
                                : getWatchOptions(optionsForStatic.watch)
                        : def.watch,
                };
            }
            if (Server.isAbsoluteURL(item.directory)) {
                throw new Error('Using a URL as static.directory is not supported');
            }
            return item;
        };
        if (typeof options.allowedHosts === 'undefined') {
            // AllowedHosts allows some default hosts picked from `options.host` or `webSocketURL.hostname` and `localhost`
            options.allowedHosts = 'auto';
        }
        // We store allowedHosts as array when supplied as string
        else if (typeof options.allowedHosts === 'string' &&
            options.allowedHosts !== 'auto' &&
            options.allowedHosts !== 'all') {
            options.allowedHosts = [options.allowedHosts];
        }
        // CLI pass options as array, we should normalize them
        else if (Array.isArray(options.allowedHosts) &&
            options.allowedHosts.includes('all')) {
            options.allowedHosts = 'all';
        }
        if (typeof options.bonjour === 'undefined') {
            options.bonjour = false;
        }
        else if (typeof options.bonjour === 'boolean') {
            options.bonjour = options.bonjour ? {} : false;
        }
        if (typeof options.client === 'undefined' ||
            (typeof options.client === 'object' && options.client !== null)) {
            if (!options.client) {
                options.client = {};
            }
            if (typeof options.client.webSocketURL === 'undefined') {
                options.client.webSocketURL = {};
            }
            else if (typeof options.client.webSocketURL === 'string') {
                const parsedURL = new URL(options.client.webSocketURL);
                options.client.webSocketURL = {
                    protocol: parsedURL.protocol,
                    hostname: parsedURL.hostname,
                    port: parsedURL.port.length > 0 ? Number(parsedURL.port) : '',
                    pathname: parsedURL.pathname,
                    username: parsedURL.username,
                    password: parsedURL.password,
                };
            }
            else if (typeof options.client.webSocketURL.port === 'string') {
                options.client.webSocketURL.port = Number(options.client.webSocketURL.port);
            }
            // Enable client overlay by default
            if (typeof options.client.overlay === 'undefined') {
                options.client.overlay = true;
            }
            else if (typeof options.client.overlay !== 'boolean') {
                options.client.overlay = {
                    errors: true,
                    warnings: true,
                    ...options.client.overlay,
                };
            }
            if (typeof options.client.reconnect === 'undefined') {
                options.client.reconnect = 10;
            }
            else if (options.client.reconnect === true) {
                options.client.reconnect = Number.POSITIVE_INFINITY;
            }
            else if (options.client.reconnect === false) {
                options.client.reconnect = 0;
            }
            // Respect infrastructureLogging.level
            if (typeof options.client.logging === 'undefined') {
                options.client.logging = compilerOptions.infrastructureLogging
                    ? compilerOptions.infrastructureLogging.level
                    : 'info';
            }
        }
        if (typeof options.compress === 'undefined') {
            options.compress = true;
        }
        if (typeof options.devMiddleware === 'undefined') {
            options.devMiddleware = {};
        }
        // No need to normalize `headers`
        if (typeof options.historyApiFallback === 'undefined') {
            options.historyApiFallback = false;
        }
        else if (typeof options.historyApiFallback === 'boolean' &&
            options.historyApiFallback) {
            options.historyApiFallback = {};
        }
        // No need to normalize `host`
        options.hot =
            typeof options.hot === 'boolean' || options.hot === 'only'
                ? options.hot
                : true;
        if (typeof options.server === 'function' ||
            typeof options.server === 'string') {
            options.server = {
                type: options.server,
                options: {},
            };
        }
        else {
            const serverOptions = options.server || {};
            options.server = {
                type: serverOptions.type || 'http',
                options: { ...serverOptions.options },
            };
        }
        const serverOptions = options.server.options;
        if (options.server.type === 'spdy' &&
            typeof serverOptions.spdy === 'undefined') {
            serverOptions.spdy = { protocols: ['h2', 'http/1.1'] };
        }
        if (options.server.type === 'https' ||
            options.server.type === 'http2' ||
            options.server.type === 'spdy') {
            if (typeof serverOptions.requestCert === 'undefined') {
                serverOptions.requestCert = false;
            }
            const httpsProperties = [
                'ca',
                'cert',
                'crl',
                'key',
                'pfx',
            ];
            for (const property of httpsProperties) {
                if (typeof serverOptions[property] === 'undefined') {
                    // eslint-disable-next-line no-continue
                    continue;
                }
                const value = serverOptions[property];
                const readFile = (item) => {
                    if (Buffer.isBuffer(item) ||
                        (typeof item === 'object' && item !== null && !Array.isArray(item))) {
                        return item;
                    }
                    if (item) {
                        let stats = null;
                        try {
                            stats = fs.lstatSync(fs.realpathSync(item)).isFile();
                        }
                        catch (error) {
                            // Ignore error
                        }
                        // It is a file
                        return stats ? fs.readFileSync(item) : item;
                    }
                };
                // @ts-expect-error too complex
                serverOptions[property] = (Array.isArray(value)
                    ? value.map((item) => readFile(item))
                    : readFile(value));
            }
            let fakeCert;
            if (!serverOptions.key || !serverOptions.cert) {
                const certificateDir = Server.findCacheDir();
                const certificatePath = path.join(certificateDir, 'server.pem');
                let certificateExists;
                try {
                    const certificate = await fs.promises.stat(certificatePath);
                    certificateExists = certificate.isFile();
                }
                catch {
                    certificateExists = false;
                }
                if (certificateExists) {
                    const certificateTtl = 1000 * 60 * 60 * 24;
                    const certificateStat = await fs.promises.stat(certificatePath);
                    const now = Number(new Date());
                    // cert is more than 30 days old, kill it with fire
                    if ((now - Number(certificateStat.ctime)) / certificateTtl > 30) {
                        this.logger.info('SSL certificate is more than 30 days old. Removing...');
                        await fs.promises.rm(certificatePath, { recursive: true });
                        certificateExists = false;
                    }
                }
                if (!certificateExists) {
                    this.logger.info('Generating SSL certificate...');
                    const selfsigned = require('selfsigned');
                    const attributes = [{ name: 'commonName', value: 'localhost' }];
                    const pems = selfsigned.generate(attributes, {
                        algorithm: 'sha256',
                        days: 30,
                        keySize: 2048,
                        extensions: [
                            {
                                name: 'basicConstraints',
                                cA: true,
                            },
                            {
                                name: 'keyUsage',
                                keyCertSign: true,
                                digitalSignature: true,
                                nonRepudiation: true,
                                keyEncipherment: true,
                                dataEncipherment: true,
                            },
                            {
                                name: 'extKeyUsage',
                                serverAuth: true,
                                clientAuth: true,
                                codeSigning: true,
                                timeStamping: true,
                            },
                            {
                                name: 'subjectAltName',
                                altNames: [
                                    {
                                        // type 2 is DNS
                                        type: 2,
                                        value: 'localhost',
                                    },
                                    {
                                        type: 2,
                                        value: 'localhost.localdomain',
                                    },
                                    {
                                        type: 2,
                                        value: 'lvh.me',
                                    },
                                    {
                                        type: 2,
                                        value: '*.lvh.me',
                                    },
                                    {
                                        type: 2,
                                        value: '[::1]',
                                    },
                                    {
                                        // type 7 is IP
                                        type: 7,
                                        ip: '127.0.0.1',
                                    },
                                    {
                                        type: 7,
                                        ip: 'fe80::1',
                                    },
                                ],
                            },
                        ],
                    });
                    await fs.promises.mkdir(certificateDir, { recursive: true });
                    await fs.promises.writeFile(certificatePath, pems.private + pems.cert, {
                        encoding: 'utf8',
                    });
                }
                fakeCert = await fs.promises.readFile(certificatePath);
                this.logger.info(`SSL certificate: ${certificatePath}`);
            }
            serverOptions.key = serverOptions.key || fakeCert;
            serverOptions.cert = serverOptions.cert || fakeCert;
        }
        if (typeof options.ipc === 'boolean') {
            const isWindows = process.platform === 'win32';
            const pipePrefix = isWindows ? '\\\\.\\pipe\\' : os.tmpdir();
            const pipeName = 'webpack-dev-server.sock';
            options.ipc = path.join(pipePrefix, pipeName);
        }
        options.liveReload =
            typeof options.liveReload !== 'undefined' ? options.liveReload : true;
        // https://github.com/webpack/webpack-dev-server/issues/1990
        const defaultOpenOptions = { wait: false };
        const getOpenItemsFromObject = ({ target, ...rest }) => {
            const normalizedOptions = {
                ...defaultOpenOptions,
                ...rest,
            };
            if (typeof normalizedOptions.app === 'string') {
                normalizedOptions.app = {
                    name: normalizedOptions.app,
                };
            }
            const normalizedTarget = typeof target === 'undefined' ? '<url>' : target;
            if (Array.isArray(normalizedTarget)) {
                return normalizedTarget.map((singleTarget) => {
                    return { target: singleTarget, options: normalizedOptions };
                });
            }
            return [{ target: normalizedTarget, options: normalizedOptions }];
        };
        if (typeof options.open === 'undefined') {
            options.open = [];
        }
        else if (typeof options.open === 'boolean') {
            options.open = options.open
                ? [
                    {
                        target: '<url>',
                        options: defaultOpenOptions,
                    },
                ]
                : [];
        }
        else if (typeof options.open === 'string') {
            options.open = [
                { target: options.open, options: defaultOpenOptions },
            ];
        }
        else if (Array.isArray(options.open)) {
            const result = [];
            for (const item of options.open) {
                if (typeof item === 'string') {
                    result.push({ target: item, options: defaultOpenOptions });
                    // eslint-disable-next-line no-continue
                    continue;
                }
                result.push(...getOpenItemsFromObject(item));
            }
            options.open = result;
        }
        else {
            options.open = [
                ...getOpenItemsFromObject(options.open),
            ];
        }
        if (typeof options.port === 'string' && options.port !== 'auto') {
            options.port = Number(options.port);
        }
        /**
         * Assume a proxy configuration specified as:
         * proxy: {
         *   'context': { options }
         * }
         * OR
         * proxy: {
         *   'context': 'target'
         * }
         */
        if (typeof options.proxy !== 'undefined') {
            options.proxy = options.proxy.map((item) => {
                if (typeof item === 'function') {
                    return item;
                }
                const getLogLevelForProxy = (level) => {
                    if (level === 'none') {
                        return 'silent';
                    }
                    if (level === 'log') {
                        return 'info';
                    }
                    if (level === 'verbose') {
                        return 'debug';
                    }
                    return level;
                };
                if (typeof item.logLevel === 'undefined') {
                    item.logLevel = getLogLevelForProxy(compilerOptions.infrastructureLogging
                        ? compilerOptions.infrastructureLogging.level
                        : 'info');
                }
                if (typeof item.logProvider === 'undefined') {
                    item.logProvider = () => this.logger;
                }
                return item;
            });
        }
        if (typeof options.setupExitSignals === 'undefined') {
            options.setupExitSignals = true;
        }
        if (typeof options.static === 'undefined') {
            options.static = [getStaticItem()];
        }
        else if (typeof options.static === 'boolean') {
            options.static = options.static ? [getStaticItem()] : false;
        }
        else if (typeof options.static === 'string') {
            options.static = [getStaticItem(options.static)];
        }
        else if (Array.isArray(options.static)) {
            options.static = options.static.map((item) => getStaticItem(item));
        }
        else {
            options.static = [getStaticItem(options.static)];
        }
        if (typeof options.watchFiles === 'string') {
            options.watchFiles = [
                { paths: options.watchFiles, options: getWatchOptions() },
            ];
        }
        else if (typeof options.watchFiles === 'object' &&
            options.watchFiles !== null &&
            !Array.isArray(options.watchFiles)) {
            options.watchFiles = [
                {
                    paths: options.watchFiles.paths,
                    options: getWatchOptions(options.watchFiles.options || {}),
                },
            ];
        }
        else if (Array.isArray(options.watchFiles)) {
            options.watchFiles = options.watchFiles.map((item) => {
                if (typeof item === 'string') {
                    return { paths: item, options: getWatchOptions() };
                }
                return {
                    paths: item.paths,
                    options: getWatchOptions(item.options || {}),
                };
            });
        }
        else {
            options.watchFiles = [];
        }
        const defaultWebSocketServerType = 'ws';
        const defaultWebSocketServerOptions = { path: '/ws' };
        if (typeof options.webSocketServer === 'undefined') {
            options.webSocketServer = {
                type: defaultWebSocketServerType,
                options: defaultWebSocketServerOptions,
            };
        }
        else if (typeof options.webSocketServer === 'boolean' &&
            !options.webSocketServer) {
            options.webSocketServer = false;
        }
        else if (typeof options.webSocketServer === 'string' ||
            typeof options.webSocketServer === 'function') {
            options.webSocketServer = {
                type: options.webSocketServer,
                options: defaultWebSocketServerOptions,
            };
        }
        else {
            options.webSocketServer = {
                type: options.webSocketServer.type ||
                    defaultWebSocketServerType,
                options: {
                    ...defaultWebSocketServerOptions,
                    ...options.webSocketServer.options,
                },
            };
            const webSocketServer = options.webSocketServer;
            if (typeof webSocketServer.options.port === 'string') {
                webSocketServer.options.port = Number(webSocketServer.options.port);
            }
        }
    }
    /**
     * @private
     * @returns {string} client transport
     */
    getClientTransport() {
        let clientImplementation;
        let clientImplementationFound = true;
        const isKnownWebSocketServerImplementation = this.options.webSocketServer &&
            typeof this.options.webSocketServer
                .type === 'string' &&
            // @ts-expect-error
            (this.options.webSocketServer.type === 'ws' ||
                this.options.webSocketServer.type ===
                    'sockjs');
        let clientTransport;
        if (this.options.client) {
            if (typeof this.options.client
                .webSocketTransport !== 'undefined') {
                clientTransport = this.options.client
                    .webSocketTransport;
            }
            else if (isKnownWebSocketServerImplementation) {
                clientTransport = this.options.webSocketServer.type;
            }
            else {
                clientTransport = 'ws';
            }
        }
        else {
            clientTransport = 'ws';
        }
        switch (typeof clientTransport) {
            case 'string':
                // could be 'sockjs', 'ws', or a path that should be required
                if (clientTransport === 'sockjs') {
                    clientImplementation = require.resolve('../client/clients/SockJSClient');
                }
                else if (clientTransport === 'ws') {
                    clientImplementation = require.resolve('../client/clients/WebSocketClient');
                }
                else {
                    try {
                        clientImplementation = require.resolve(clientTransport);
                    }
                    catch {
                        clientImplementationFound = false;
                    }
                }
                break;
            default:
                clientImplementationFound = false;
        }
        if (!clientImplementationFound) {
            throw new Error(`${!isKnownWebSocketServerImplementation
                ? 'When you use custom web socket implementation you must explicitly specify client.webSocketTransport. '
                : ''}client.webSocketTransport must be a string denoting a default implementation (e.g. 'sockjs', 'ws') or a full path to a JS file via require.resolve(...) which exports a class `);
        }
        return clientImplementation;
    }
    getServerTransport() {
        let implementation;
        let implementationFound = true;
        switch (typeof this.options.webSocketServer.type) {
            case 'string':
                // Could be 'sockjs', in the future 'ws', or a path that should be required
                if (this.options.webSocketServer
                    .type === 'sockjs') {
                    implementation = require('./servers/SockJSServer');
                }
                else if (this.options.webSocketServer
                    .type === 'ws') {
                    implementation = require('./servers/WebsocketServer');
                }
                else {
                    try {
                        implementation = require(this.options.webSocketServer
                            .type);
                    }
                    catch {
                        implementationFound = false;
                    }
                }
                break;
            case 'function':
                implementation = this.options.webSocketServer.type;
                break;
            default:
                implementationFound = false;
        }
        if (!implementationFound) {
            throw new Error("webSocketServer (webSocketServer.type) must be a string denoting a default implementation (e.g. 'ws', 'sockjs'), a full path to " +
                'a JS file which exports a class extending BaseServer (webpack-dev-server/lib/servers/BaseServer.js) ' +
                'via require.resolve(...), or the class itself which extends BaseServer');
        }
        return implementation;
    }
    getClientEntry() {
        return require.resolve('@rspack/dev-server/client/index');
    }
    getClientHotEntry() {
        if (this.options.hot === 'only') {
            return require.resolve('@rspack/core/hot/only-dev-server');
        }
        if (this.options.hot) {
            return require.resolve('@rspack/core/hot/dev-server');
        }
    }
    setupProgressPlugin() {
        const { ProgressPlugin } = this.compiler.compilers
            ? this.compiler.compilers[0].webpack
            : this.compiler.webpack;
        new ProgressPlugin((percent, msg, addInfo, pluginName) => {
            const percentValue = Math.floor(percent * 100);
            let msgValue = msg;
            if (percentValue === 100) {
                msgValue = 'Compilation completed';
            }
            if (addInfo) {
                msgValue = `${msgValue} (${addInfo})`;
            }
            if (this.webSocketServer) {
                this.sendMessage(this.webSocketServer.clients, 'progress-update', {
                    percent: percentValue,
                    msg: msgValue,
                    pluginName,
                });
            }
            if (this.server) {
                this.server.emit('progress-update', { percent, msg, pluginName });
            }
        }).apply(this.compiler);
    }
    /**
     * @private
     * @returns {Promise<void>}
     */
    async initialize() {
        const compilers = isMultiCompiler(this.compiler)
            ? this.compiler.compilers
            : [this.compiler];
        for (const compiler of compilers) {
            const mode = compiler.options.mode || process.env.NODE_ENV;
            if (this.options.hot) {
                if (mode === 'production') {
                    this.logger.warn('Hot Module Replacement (HMR) is enabled for the production build. \n' +
                        'Make sure to disable HMR for production by setting `devServer.hot` to `false` in the configuration.');
                }
                compiler.options.resolve.alias = {
                    'ansi-html-community': require.resolve('@rspack/dev-server/client/utils/ansiHTML'),
                    ...compiler.options.resolve.alias,
                };
            }
        }
        this.setupHooks();
        await this.setupApp();
        await this.createServer();
        if (this.options.webSocketServer) {
            const compilers = this.compiler.compilers ||
                [this.compiler];
            for (const compiler of compilers) {
                if (compiler.options.devServer === false) {
                    continue;
                }
                this.addAdditionalEntries(compiler);
                const webpack = compiler.webpack || require('webpack');
                new webpack.ProvidePlugin({
                    __webpack_dev_server_client__: this.getClientTransport(),
                }).apply(compiler);
                if (this.options.hot) {
                    const HMRPluginExists = compiler.options.plugins.find((plugin) => plugin &&
                        plugin.constructor === webpack.HotModuleReplacementPlugin);
                    if (HMRPluginExists) {
                        this.logger.warn('"hot: true" automatically applies HMR plugin, you don\'t have to add it manually to your webpack configuration.');
                    }
                    else {
                        // Apply the HMR plugin
                        const plugin = new webpack.HotModuleReplacementPlugin();
                        plugin.apply(compiler);
                    }
                }
            }
            if (this.options.client &&
                this.options.client.progress) {
                this.setupProgressPlugin();
            }
        }
        this.setupWatchFiles();
        this.setupWatchStaticFiles();
        this.setupMiddlewares();
        if (this.options.setupExitSignals) {
            const signals = ['SIGINT', 'SIGTERM'];
            let needForceShutdown = false;
            for (const signal of signals) {
                // eslint-disable-next-line no-loop-func
                const listener = () => {
                    if (needForceShutdown) {
                        // eslint-disable-next-line n/no-process-exit
                        process.exit();
                    }
                    this.logger.info('Gracefully shutting down. To force exit, press ^C again. Please wait...');
                    needForceShutdown = true;
                    this.stopCallback(() => {
                        if (typeof this.compiler.close === 'function') {
                            this.compiler.close(() => {
                                // eslint-disable-next-line n/no-process-exit
                                process.exit();
                            });
                        }
                        else {
                            // eslint-disable-next-line n/no-process-exit
                            process.exit();
                        }
                    });
                };
                this.listeners.push({ name: signal, listener });
                process.on(signal, listener);
            }
        }
        // Proxy WebSocket without the initial http request
        // https://github.com/chimurai/http-proxy-middleware#external-websocket-upgrade
        const webSocketProxies = this.webSocketProxies;
        for (const webSocketProxy of webSocketProxies) {
            this.server.on('upgrade', webSocketProxy.upgrade);
        }
    }
    async setupApp() {
        this.app = (typeof this.options.app === 'function'
            ? await this.options.app()
            : getExpress()());
    }
    getStats(statsObj) {
        const stats = Server.DEFAULT_STATS;
        const compilerOptions = this.getCompilerOptions();
        if (compilerOptions.stats &&
            compilerOptions.stats
                .warningsFilter) {
            stats.warningsFilter = compilerOptions.stats.warningsFilter;
        }
        return statsObj.toJson(stats);
    }
    setupHooks() {
        this.compiler.hooks.invalid.tap('webpack-dev-server', () => {
            if (this.webSocketServer) {
                this.sendMessage(this.webSocketServer.clients, 'invalid');
            }
        });
        this.compiler.hooks.done.tap('webpack-dev-server', (stats) => {
            if (this.webSocketServer) {
                this.sendStats(this.webSocketServer.clients, this.getStats(stats));
            }
            this.stats = stats;
        });
    }
    setupWatchStaticFiles() {
        const watchFiles = this.options.static;
        if (watchFiles.length > 0) {
            for (const item of watchFiles) {
                if (item.watch) {
                    this.watchFiles(item.directory, item.watch);
                }
            }
        }
    }
    setupWatchFiles() {
        const watchFiles = this.options.watchFiles;
        if (watchFiles.length > 0) {
            for (const item of watchFiles) {
                this.watchFiles(item.paths, item.options);
            }
        }
    }
    setupMiddlewares() {
        let middlewares = [];
        // Register setup host header check for security
        middlewares.push({
            name: 'host-header-check',
            middleware: (req, res, next) => {
                const headers = req.headers;
                const headerName = headers[':authority'] ? ':authority' : 'host';
                if (this.isValidHost(headers, headerName)) {
                    next();
                    return;
                }
                res.statusCode = 403;
                res.end('Invalid Host header');
            },
        });
        // Register setup cross origin request check for security
        middlewares.push({
            name: 'cross-origin-header-check',
            middleware: (req, res, next) => {
                const headers = req.headers;
                const headerName = headers[':authority'] ? ':authority' : 'host';
                if (this.isValidHost(headers, headerName, false)) {
                    next();
                    return;
                }
                if (headers['sec-fetch-mode'] === 'no-cors' &&
                    headers['sec-fetch-site'] === 'cross-site') {
                    res.statusCode = 403;
                    res.end('Cross-Origin request blocked');
                    return;
                }
                next();
            },
        });
        const isHTTP2 = this.options.server.type === 'http2';
        if (isHTTP2) {
            // TODO patch for https://github.com/pillarjs/finalhandler/pull/45, need remove then will be resolved
            middlewares.push({
                name: 'http2-status-message-patch',
                middleware: (_req, res, next) => {
                    Object.defineProperty(res, 'statusMessage', {
                        get() {
                            return '';
                        },
                        set() { },
                    });
                    next();
                },
            });
        }
        // compress is placed last and uses unshift so that it will be the first middleware used
        if (this.options.compress && !isHTTP2) {
            const compression = require('compression');
            middlewares.push({ name: 'compression', middleware: compression() });
        }
        if (typeof this.options.headers !== 'undefined') {
            middlewares.push({
                name: 'set-headers',
                middleware: this.setHeaders.bind(this),
            });
        }
        middlewares.push({
            name: 'webpack-dev-middleware',
            middleware: this.middleware,
        });
        // Should be after `webpack-dev-middleware`, otherwise other middlewares might rewrite response
        middlewares.push({
            name: 'webpack-dev-server-sockjs-bundle',
            path: '/__webpack_dev_server__/sockjs.bundle.js',
            middleware: (req, res, next) => {
                if (req.method !== 'GET' && req.method !== 'HEAD') {
                    next();
                    return;
                }
                const clientPath = path.join(__dirname, '../', 'client/modules/sockjs-client/index.js');
                // Express send Etag and other headers by default, so let's keep them for compatibility reasons
                if (typeof res.sendFile === 'function') {
                    res.sendFile(clientPath);
                    return;
                }
                let stats;
                try {
                    // TODO implement `inputFileSystem.createReadStream` in webpack
                    stats = fs.statSync(clientPath);
                }
                catch {
                    next();
                    return;
                }
                res.setHeader('Content-Type', 'application/javascript; charset=UTF-8');
                res.setHeader('Content-Length', stats.size);
                if (req.method === 'HEAD') {
                    res.end();
                    return;
                }
                fs.createReadStream(clientPath).pipe(res);
            },
        });
        middlewares.push({
            name: 'webpack-dev-server-invalidate',
            path: '/webpack-dev-server/invalidate',
            middleware: (req, res, next) => {
                if (req.method !== 'GET' && req.method !== 'HEAD') {
                    next();
                    return;
                }
                this.invalidate();
                res.end();
            },
        });
        middlewares.push({
            name: 'webpack-dev-server-open-editor',
            path: '/webpack-dev-server/open-editor',
            middleware: (req, res, next) => {
                if (req.method !== 'GET' && req.method !== 'HEAD') {
                    next();
                    return;
                }
                if (!req.url) {
                    next();
                    return;
                }
                const resolveUrl = new URL(req.url, `http://${req.headers.host}`);
                const params = new URLSearchParams(resolveUrl.search);
                const fileName = params.get('fileName');
                if (typeof fileName === 'string') {
                    const launchEditor = require('launch-editor');
                    launchEditor(fileName);
                }
                res.end();
            },
        });
        middlewares.push({
            name: 'webpack-dev-server-assets',
            path: '/webpack-dev-server',
            middleware: (req, res, next) => {
                if (req.method !== 'GET' && req.method !== 'HEAD') {
                    next();
                    return;
                }
                if (!this.middleware) {
                    next();
                    return;
                }
                this.middleware.waitUntilValid((stats) => {
                    res.setHeader('Content-Type', 'text/html; charset=utf-8');
                    // HEAD requests should not return body content
                    if (req.method === 'HEAD') {
                        res.end();
                        return;
                    }
                    res.write('<!DOCTYPE html><html><head><meta charset="utf-8"/></head><body>');
                    const statsForPrint = typeof stats.stats !== 'undefined'
                        ? stats.toJson({})
                            .children
                        : [stats.toJson()];
                    res.write('<h1>Assets Report:</h1>');
                    for (const [index, item] of statsForPrint?.entries() ?? []) {
                        res.write('<div>');
                        const name = typeof item.name !== 'undefined'
                            ? item.name
                            : stats.stats
                                ? `unnamed[${index}]`
                                : 'unnamed';
                        res.write(`<h2>Compilation: ${name}</h2>`);
                        res.write('<ul>');
                        const publicPath = item.publicPath === 'auto' ? '' : item.publicPath;
                        const assets = item.assets;
                        for (const asset of assets ?? []) {
                            const assetName = asset.name;
                            const assetURL = `${publicPath}${assetName}`;
                            res.write(`<li>
              <strong><a href="${assetURL}" target="_blank">${assetName}</a></strong>
            </li>`);
                        }
                        res.write('</ul>');
                        res.write('</div>');
                    }
                    res.end('</body></html>');
                });
            },
        });
        if (this.options.proxy) {
            const { createProxyMiddleware } = require('http-proxy-middleware');
            const getProxyMiddleware = (proxyConfig) => {
                // It is possible to use the `bypass` method without a `target` or `router`.
                // However, the proxy middleware has no use in this case, and will fail to instantiate.
                if (proxyConfig.target) {
                    const context = proxyConfig.context || proxyConfig.path;
                    return createProxyMiddleware(context, proxyConfig);
                }
                if (proxyConfig.router) {
                    return createProxyMiddleware(proxyConfig);
                }
                // TODO improve me after drop `bypass` to always generate error when configuration is bad
                if (!proxyConfig.bypass) {
                    util.deprecate(() => { }, `Invalid proxy configuration:\n\n${JSON.stringify(proxyConfig, null, 2)}\n\nThe use of proxy object notation as proxy routes has been removed.\nPlease use the 'router' or 'context' options. Read more at https://github.com/chimurai/http-proxy-middleware/tree/v2.0.6#http-proxy-middleware-options`, 'DEP_WEBPACK_DEV_SERVER_PROXY_ROUTES_ARGUMENT')();
                }
            };
            /**
             * @example
             * Assume a proxy configuration specified as:
             * proxy: [
             *   {
             *     context: "value",
             *     ...options,
             *   },
             *   // or:
             *   function() {
             *     return {
             *       context: "context",
             *       ...options,
             *     };
             *   }
             * ]
             */
            for (const proxyConfigOrCallback of this.options.proxy) {
                let proxyMiddleware;
                let proxyConfig = typeof proxyConfigOrCallback === 'function'
                    ? proxyConfigOrCallback()
                    : proxyConfigOrCallback;
                proxyMiddleware = getProxyMiddleware(proxyConfig);
                if (proxyConfig.ws && proxyMiddleware) {
                    this.webSocketProxies.push(proxyMiddleware);
                }
                const handler = async (req, res, next) => {
                    if (typeof proxyConfigOrCallback === 'function') {
                        const newProxyConfig = proxyConfigOrCallback(req, res, next);
                        if (newProxyConfig !== proxyConfig) {
                            proxyConfig = newProxyConfig;
                            const socket = req.socket || req.connection;
                            const server = socket ? socket.server : null;
                            if (server) {
                                server.removeAllListeners('close');
                            }
                            proxyMiddleware = getProxyMiddleware(proxyConfig);
                        }
                    }
                    // - Check if we have a bypass function defined
                    // - In case the bypass function is defined we'll retrieve the
                    // bypassUrl from it otherwise bypassUrl would be null
                    // TODO remove in the next major in favor `context` and `router` options
                    const isByPassFuncDefined = typeof proxyConfig.bypass === 'function';
                    if (isByPassFuncDefined) {
                        util.deprecate(() => { }, "Using the 'bypass' option is deprecated. Please use the 'router' or 'context' options. Read more at https://github.com/chimurai/http-proxy-middleware/tree/v2.0.6#http-proxy-middleware-options", 'DEP_WEBPACK_DEV_SERVER_PROXY_BYPASS_ARGUMENT')();
                    }
                    const bypassUrl = isByPassFuncDefined
                        ? await proxyConfig.bypass(req, res, proxyConfig)
                        : null;
                    if (typeof bypassUrl === 'boolean') {
                        // skip the proxy
                        res.statusCode = 404;
                        req.url = '';
                        next();
                    }
                    else if (typeof bypassUrl === 'string') {
                        // byPass to that url
                        req.url = bypassUrl;
                        next();
                    }
                    else if (proxyMiddleware) {
                        return proxyMiddleware(req, res, next);
                    }
                    else {
                        next();
                    }
                };
                middlewares.push({
                    name: 'http-proxy-middleware',
                    middleware: handler,
                });
                // Also forward error requests to the proxy so it can handle them.
                middlewares.push({
                    name: 'http-proxy-middleware-error-handler',
                    middleware: (error, req, res, next) => handler(req, res, next),
                });
            }
            middlewares.push({
                name: 'webpack-dev-middleware',
                middleware: this.middleware,
            });
        }
        const staticOptions = this.options.static;
        if (staticOptions.length > 0) {
            for (const staticOption of staticOptions) {
                for (const publicPath of staticOption.publicPath) {
                    middlewares.push({
                        name: 'express-static',
                        path: publicPath,
                        middleware: getExpress().static(staticOption.directory, staticOption.staticOptions),
                    });
                }
            }
        }
        if (this.options.historyApiFallback) {
            const connectHistoryApiFallback = require('connect-history-api-fallback');
            const { historyApiFallback } = this.options;
            if (typeof historyApiFallback ===
                'undefined' &&
                !historyApiFallback.verbose) {
                historyApiFallback.logger = this.logger.log.bind(this.logger, '[connect-history-api-fallback]');
            }
            // Fall back to /index.html if nothing else matches.
            middlewares.push({
                name: 'connect-history-api-fallback',
                middleware: connectHistoryApiFallback(historyApiFallback),
            });
            // include our middleware to ensure
            // it is able to handle '/index.html' request after redirect
            middlewares.push({
                name: 'webpack-dev-middleware',
                middleware: this.middleware,
            });
            if (staticOptions.length > 0) {
                for (const staticOption of staticOptions) {
                    for (const publicPath of staticOption.publicPath) {
                        middlewares.push({
                            name: 'express-static',
                            path: publicPath,
                            middleware: getExpress().static(staticOption.directory, staticOption.staticOptions),
                        });
                    }
                }
            }
        }
        if (staticOptions.length > 0) {
            const serveIndex = require('serve-index');
            for (const staticOption of staticOptions) {
                for (const publicPath of staticOption.publicPath) {
                    if (staticOption.serveIndex) {
                        middlewares.push({
                            name: 'serve-index',
                            path: publicPath,
                            middleware: (req, res, next) => {
                                // serve-index doesn't fallthrough non-get/head request to next middleware
                                if (req.method !== 'GET' && req.method !== 'HEAD') {
                                    return next();
                                }
                                serveIndex(staticOption.directory, staticOption.serveIndex)(req, res, next);
                            },
                        });
                    }
                }
            }
        }
        // Register this middleware always as the last one so that it's only used as a
        // fallback when no other middleware responses.
        middlewares.push({
            name: 'options-middleware',
            middleware: (req, res, next) => {
                if (req.method === 'OPTIONS') {
                    res.statusCode = 204;
                    res.setHeader('Content-Length', '0');
                    res.end();
                    return;
                }
                next();
            },
        });
        if (typeof this.options.setupMiddlewares === 'function') {
            middlewares = this.options.setupMiddlewares(middlewares, this);
        }
        // Lazy init webpack dev middleware
        const lazyInitDevMiddleware = () => {
            if (!this.middleware) {
                const webpackDevMiddleware = require('webpack-dev-middleware');
                // middleware for serving webpack bundle
                this.middleware = webpackDevMiddleware(this.compiler, this.options.devMiddleware);
            }
            return this.middleware;
        };
        for (const i of middlewares) {
            if (i.name === 'webpack-dev-middleware') {
                const item = i;
                if (typeof item.middleware === 'undefined') {
                    item.middleware =
                        lazyInitDevMiddleware();
                }
            }
        }
        for (const middleware of middlewares) {
            if (typeof middleware === 'function') {
                this.app.use(middleware);
            }
            else if (typeof middleware.path !== 'undefined') {
                this.app.use(middleware.path, middleware.middleware);
            }
            else {
                this.app.use(middleware.middleware);
            }
        }
    }
    /**
     * @private
     * @returns {Promise<void>}
     */
    async createServer() {
        const { type, options } = this.options.server;
        if (typeof type === 'function') {
            this.server = await type(options, this.app);
        }
        else {
            const serverType = require(type);
            this.server =
                type === 'http2'
                    ? serverType.createSecureServer({ ...options, allowHTTP1: true }, this.app)
                    : serverType.createServer(options, this.app);
        }
        this.isTlsServer =
            typeof this.server
                .setSecureContext !== 'undefined';
        this.server.on('connection', (socket) => {
            // Add socket to list
            this.sockets.push(socket);
            socket.once('close', () => {
                // Remove socket from list
                this.sockets.splice(this.sockets.indexOf(socket), 1);
            });
        });
        this.server.on('error', (error) => {
            throw error;
        });
    }
    createWebSocketServer() {
        // @ts-expect-error constructor
        this.webSocketServer = new (this.getServerTransport())(this);
        (this.webSocketServer?.implementation).on('connection', (client, request) => {
            const headers = typeof request !== 'undefined'
                ? request.headers
                : typeof client
                    .headers !== 'undefined'
                    ? client.headers
                    : undefined;
            if (!headers) {
                this.logger.warn('webSocketServer implementation must pass headers for the "connection" event');
            }
            if (!headers ||
                !this.isValidHost(headers, 'host') ||
                !this.isValidHost(headers, 'origin') ||
                !this.isSameOrigin(headers)) {
                this.sendMessage([client], 'error', 'Invalid Host/Origin header');
                // With https enabled, the sendMessage above is encrypted asynchronously so not yet sent
                // Terminate would prevent it sending, so use close to allow it to be sent
                client.close();
                return;
            }
            if (this.options.hot === true || this.options.hot === 'only') {
                this.sendMessage([client], 'hot');
            }
            if (this.options.liveReload) {
                this.sendMessage([client], 'liveReload');
            }
            if (this.options.client &&
                this.options.client.progress) {
                this.sendMessage([client], 'progress', this.options.client.progress);
            }
            if (this.options.client &&
                this.options.client.reconnect) {
                this.sendMessage([client], 'reconnect', this.options.client.reconnect);
            }
            if (this.options.client &&
                this.options.client.overlay) {
                const overlayConfig = this.options.client
                    .overlay;
                this.sendMessage([client], 'overlay', typeof overlayConfig === 'object'
                    ? {
                        ...overlayConfig,
                        errors: overlayConfig.errors &&
                            encodeOverlaySettings(overlayConfig.errors),
                        warnings: overlayConfig.warnings &&
                            encodeOverlaySettings(overlayConfig.warnings),
                        runtimeErrors: overlayConfig.runtimeErrors &&
                            encodeOverlaySettings(overlayConfig.runtimeErrors),
                    }
                    : overlayConfig);
            }
            if (!this.stats) {
                return;
            }
            this.sendStats([client], this.getStats(this.stats), true);
        });
    }
    async openBrowser(defaultOpenTarget) {
        const open = (await import('open')).default;
        Promise.all(this.options.open.map((item) => {
            let openTarget;
            if (item.target === '<url>') {
                openTarget = defaultOpenTarget;
            }
            else {
                openTarget = Server.isAbsoluteURL(item.target)
                    ? item.target
                    : new URL(item.target, defaultOpenTarget).toString();
            }
            // Type assertion needed: OpenOptions is compatible at runtime but TypeScript can't verify
            // the type match between our type definition and the ES module's type in CommonJS context
            return open(openTarget, item.options).catch(() => {
                const app = item.options.app;
                this.logger.warn(`Unable to open "${openTarget}" page${app
                    ? ` in "${app.name}" app${app.arguments
                        ? ` with "${app.arguments.join(' ')}" arguments`
                        : ''}`
                    : ''}. If you are running in a headless environment, please do not use the "open" option or related flags like "--open", "--open-target", and "--open-app-name".`);
            });
        }));
    }
    runBonjour() {
        const { Bonjour } = require('bonjour-service');
        const type = this.isTlsServer ? 'https' : 'http';
        this.bonjour = new Bonjour();
        this.bonjour?.publish({
            name: `Webpack Dev Server ${os.hostname()}:${this.options.port}`,
            port: this.options.port,
            type,
            subtypes: ['webpack'],
            ...this.options.bonjour,
        });
    }
    stopBonjour(callback = () => { }) {
        this.bonjour?.unpublishAll(() => {
            this.bonjour?.destroy();
            if (callback) {
                callback();
            }
        });
    }
    async logStatus() {
        const { cyan, isColorSupported, red } = require('colorette');
        const getColorsOption = (compilerOptions) => {
            let colorsEnabled;
            if (compilerOptions.stats &&
                typeof compilerOptions.stats.colors !==
                    'undefined') {
                colorsEnabled = compilerOptions.stats
                    .colors;
            }
            else {
                colorsEnabled = isColorSupported;
            }
            return colorsEnabled;
        };
        const colors = {
            info(useColor, msg) {
                if (useColor) {
                    return cyan(msg);
                }
                return msg;
            },
            error(useColor, msg) {
                if (useColor) {
                    return red(msg);
                }
                return msg;
            },
        };
        const useColor = getColorsOption(this.getCompilerOptions());
        const server = this.server;
        if (this.options.ipc) {
            this.logger.info(`Project is running at: "${server?.address()}"`);
        }
        else {
            const protocol = this.isTlsServer ? 'https' : 'http';
            const addressInfo = server?.address();
            if (!addressInfo) {
                return;
            }
            const { address, port } = addressInfo;
            const prettyPrintURL = (newHostname) => url.format({ protocol, hostname: newHostname, port, pathname: '/' });
            let host;
            let localhost;
            let loopbackIPv4;
            let loopbackIPv6;
            let networkUrlIPv4;
            let networkUrlIPv6;
            if (this.options.host) {
                if (this.options.host === 'localhost') {
                    localhost = prettyPrintURL('localhost');
                }
                else {
                    let isIP;
                    try {
                        isIP = ipaddr.parse(this.options.host);
                    }
                    catch {
                        // Ignore
                    }
                    if (!isIP) {
                        host = prettyPrintURL(this.options.host);
                    }
                }
            }
            const parsedIP = ipaddr.parse(address);
            if (parsedIP.range() === 'unspecified') {
                localhost = prettyPrintURL('localhost');
                loopbackIPv6 = prettyPrintURL('::1');
                const networkIPv4 = Server.findIp('v4', false);
                if (networkIPv4) {
                    networkUrlIPv4 = prettyPrintURL(networkIPv4);
                }
                const networkIPv6 = Server.findIp('v6', false);
                if (networkIPv6) {
                    networkUrlIPv6 = prettyPrintURL(networkIPv6);
                }
            }
            else if (parsedIP.range() === 'loopback') {
                if (parsedIP.kind() === 'ipv4') {
                    loopbackIPv4 = prettyPrintURL(parsedIP.toString());
                }
                else if (parsedIP.kind() === 'ipv6') {
                    loopbackIPv6 = prettyPrintURL(parsedIP.toString());
                }
            }
            else {
                networkUrlIPv4 =
                    parsedIP.kind() === 'ipv6' && parsedIP.isIPv4MappedAddress()
                        ? prettyPrintURL(parsedIP.toIPv4Address().toString())
                        : prettyPrintURL(address);
                if (parsedIP.kind() === 'ipv6') {
                    networkUrlIPv6 = prettyPrintURL(address);
                }
            }
            this.logger.info('Project is running at:');
            if (host) {
                this.logger.info(`Server: ${colors.info(useColor, host)}`);
            }
            if (localhost || loopbackIPv4 || loopbackIPv6) {
                const loopbacks = [];
                if (localhost) {
                    loopbacks.push([colors.info(useColor, localhost)]);
                }
                if (loopbackIPv4) {
                    loopbacks.push([colors.info(useColor, loopbackIPv4)]);
                }
                if (loopbackIPv6) {
                    loopbacks.push([colors.info(useColor, loopbackIPv6)]);
                }
                this.logger.info(`Loopback: ${loopbacks.join(', ')}`);
            }
            if (networkUrlIPv4) {
                this.logger.info(`On Your Network (IPv4): ${colors.info(useColor, networkUrlIPv4)}`);
            }
            if (networkUrlIPv6) {
                this.logger.info(`On Your Network (IPv6): ${colors.info(useColor, networkUrlIPv6)}`);
            }
            if (this.options.open?.length > 0) {
                const openTarget = prettyPrintURL(!this.options.host ||
                    this.options.host === '0.0.0.0' ||
                    this.options.host === '::'
                    ? 'localhost'
                    : this.options.host);
                await this.openBrowser(openTarget);
            }
        }
        if (this.options.static?.length > 0) {
            this.logger.info(`Content not from webpack is served from '${colors.info(useColor, this.options.static
                .map((staticOption) => staticOption.directory)
                .join(', '))}' directory`);
        }
        if (this.options.historyApiFallback) {
            this.logger.info(`404s will fallback to '${colors.info(useColor, this.options.historyApiFallback
                .index || '/index.html')}'`);
        }
        if (this.options.bonjour) {
            const bonjourProtocol = this.options.bonjour?.type ||
                this.isTlsServer
                ? 'https'
                : 'http';
            this.logger.info(`Broadcasting "${bonjourProtocol}" with subtype of "webpack" via ZeroConf DNS (Bonjour)`);
        }
    }
    setHeaders(req, res, next) {
        let { headers } = this.options;
        if (headers) {
            if (typeof headers === 'function') {
                headers = headers(req, res, this.middleware ? this.middleware.context : undefined);
            }
            const allHeaders = [];
            if (!Array.isArray(headers)) {
                for (const name in headers) {
                    allHeaders.push({
                        key: name,
                        value: headers[name],
                    });
                }
                headers = allHeaders;
            }
            for (const { key, value } of headers) {
                res.setHeader(key, value);
            }
        }
        next();
    }
    isHostAllowed(value) {
        const { allowedHosts } = this.options;
        // allow user to opt out of this security check, at their own risk
        // by explicitly enabling allowedHosts
        if (allowedHosts === 'all') {
            return true;
        }
        // always allow localhost host, for convenience
        // allow if value is in allowedHosts
        if (Array.isArray(allowedHosts) && allowedHosts.length > 0) {
            for (const allowedHost of allowedHosts) {
                if (allowedHost === value) {
                    return true;
                }
                // support "." as a subdomain wildcard
                // e.g. ".example.com" will allow "example.com", "www.example.com", "subdomain.example.com", etc
                if (allowedHost.startsWith('.') && // "example.com"  (value === allowedHost.substring(1))
                    // "*.example.com"  (value.endsWith(allowedHost))
                    (value === allowedHost.slice(1) || value.endsWith(allowedHost))) {
                    return true;
                }
            }
        }
        // Also allow if `client.webSocketURL.hostname` provided
        if (this.options.client &&
            typeof this.options.client.webSocketURL !==
                'undefined') {
            return (this.options.client.webSocketURL === value);
        }
        return false;
    }
    isValidHost(headers, headerToCheck, validateHost = true) {
        if (this.options.allowedHosts === 'all') {
            return true;
        }
        // get the Host header and extract hostname
        // we don't care about port not matching
        const header = headers[headerToCheck];
        if (!header) {
            return false;
        }
        if (DEFAULT_ALLOWED_PROTOCOLS.test(header)) {
            return true;
        }
        // use the node url-parser to retrieve the hostname from the host-header.
        // TODO resolve me in the next major release
        // eslint-disable-next-line n/no-deprecated-api
        const { hostname } = url.parse(
        // if header doesn't have scheme, add // for parsing.
        /^(.+:)?\/\//.test(header) ? header : `//${header}`, false, true);
        if (hostname === null) {
            return false;
        }
        if (this.isHostAllowed(hostname)) {
            return true;
        }
        // always allow requests with explicit IPv4 or IPv6-address.
        // A note on IPv6 addresses:
        // header will always contain the brackets denoting
        // an IPv6-address in URLs,
        // these are removed from the hostname in url.parse(),
        // so we have the pure IPv6-address in hostname.
        // For convenience, always allow localhost (hostname === 'localhost')
        // and its subdomains (hostname.endsWith(".localhost")).
        // allow hostname of listening address  (hostname === this.options.host)
        const isValidHostname = validateHost
            ? ipaddr.IPv4.isValid(hostname) ||
                ipaddr.IPv6.isValid(hostname) ||
                hostname === 'localhost' ||
                hostname.endsWith('.localhost') ||
                hostname === this.options.host
            : false;
        return isValidHostname;
    }
    isSameOrigin(headers) {
        if (this.options.allowedHosts === 'all') {
            return true;
        }
        const originHeader = headers.origin;
        if (!originHeader) {
            return this.options.allowedHosts === 'all';
        }
        if (DEFAULT_ALLOWED_PROTOCOLS.test(originHeader)) {
            return true;
        }
        // TODO resolve me in the next major release
        // eslint-disable-next-line n/no-deprecated-api
        const origin = url.parse(originHeader, false, true).hostname;
        if (origin === null) {
            return false;
        }
        if (this.isHostAllowed(origin)) {
            return true;
        }
        const hostHeader = headers.host;
        if (!hostHeader) {
            return this.options.allowedHosts === 'all';
        }
        if (DEFAULT_ALLOWED_PROTOCOLS.test(hostHeader)) {
            return true;
        }
        // eslint-disable-next-line n/no-deprecated-api
        const host = url.parse(
        // if hostHeader doesn't have scheme, add // for parsing.
        /^(.+:)?\/\//.test(hostHeader) ? hostHeader : `//${hostHeader}`, false, true).hostname;
        if (host === null) {
            return false;
        }
        if (this.isHostAllowed(host)) {
            return true;
        }
        return origin === host;
    }
    sendMessage(clients, type, data, params) {
        for (const client of clients) {
            // `sockjs` uses `1` to indicate client is ready to accept data
            // `ws` uses `WebSocket.OPEN`, but it is mean `1` too
            if (client.readyState === 1) {
                client.send(JSON.stringify({ type, data, params }));
            }
        }
    }
    // Send stats to a socket or multiple sockets
    sendStats(clients, stats, force) {
        if (!stats) {
            return;
        }
        const shouldEmit = !force &&
            stats &&
            (!stats.errors || stats.errors.length === 0) &&
            (!stats.warnings || stats.warnings.length === 0) &&
            this.currentHash === stats.hash;
        if (shouldEmit) {
            this.sendMessage(clients, 'still-ok');
            return;
        }
        this.currentHash = stats.hash;
        this.sendMessage(clients, 'hash', stats.hash);
        if (stats.errors?.length > 0 ||
            stats.warnings?.length > 0) {
            const hasErrors = stats.errors?.length > 0;
            if (stats.warnings?.length >
                0) {
                let params;
                if (hasErrors) {
                    params = { preventReloading: true };
                }
                this.sendMessage(clients, 'warnings', stats.warnings, params);
            }
            if (stats.errors?.length > 0) {
                this.sendMessage(clients, 'errors', stats.errors);
            }
        }
        else {
            this.sendMessage(clients, 'ok');
        }
    }
    watchFiles(watchPath, watchOptions) {
        const chokidar = require('chokidar');
        const watcher = chokidar.watch(watchPath, watchOptions);
        // disabling refreshing on changing the content
        if (this.options.liveReload) {
            watcher.on('change', (item) => {
                if (this.webSocketServer) {
                    this.sendMessage(this.webSocketServer.clients, 'static-changed', item);
                }
            });
        }
        this.staticWatchers.push(watcher);
    }
    invalidate(callback = () => { }) {
        if (this.middleware) {
            this.middleware.invalidate(callback);
        }
    }
    async start() {
        await this.normalizeOptions();
        if (this.options.ipc) {
            await new Promise((resolve, reject) => {
                const net = require('node:net');
                const socket = new net.Socket();
                socket.on('error', (error) => {
                    if (error.code === 'ECONNREFUSED') {
                        // No other server listening on this socket, so it can be safely removed
                        fs.unlinkSync(this.options.ipc);
                        resolve();
                        return;
                    }
                    if (error.code === 'ENOENT') {
                        resolve();
                        return;
                    }
                    reject(error);
                });
                socket.connect({ path: this.options.ipc }, () => {
                    throw new Error(`IPC "${this.options.ipc}" is already used`);
                });
            });
        }
        else {
            this.options.host = await Server.getHostname(this.options.host);
            this.options.port = await Server.getFreePort(this.options.port, this.options.host);
        }
        await this.initialize();
        const listenOptions = this.options.ipc
            ? { path: this.options.ipc }
            : { host: this.options.host, port: this.options.port };
        await new Promise((resolve) => {
            this.server.listen(listenOptions, () => {
                resolve();
            });
        });
        if (this.options.ipc) {
            // chmod 666 (rw rw rw)
            const READ_WRITE = 438;
            await fs.promises.chmod(this.options.ipc, READ_WRITE);
        }
        if (this.options.webSocketServer) {
            this.createWebSocketServer();
        }
        if (this.options.bonjour) {
            this.runBonjour();
        }
        await this.logStatus();
        if (typeof this.options.onListening === 'function') {
            this.options.onListening(this);
        }
    }
    startCallback(callback = () => { }) {
        this.start()
            .then(() => callback(), callback)
            .catch(callback);
    }
    async stop() {
        if (this.bonjour) {
            await new Promise((resolve) => {
                this.stopBonjour(() => {
                    resolve();
                });
            });
        }
        this.webSocketProxies = [];
        await Promise.all(this.staticWatchers.map((watcher) => watcher.close()));
        this.staticWatchers = [];
        if (this.webSocketServer) {
            await new Promise((resolve) => {
                this.webSocketServer.implementation.close(() => {
                    this.webSocketServer = null;
                    resolve();
                });
                for (const client of this.webSocketServer.clients) {
                    client.terminate();
                }
                this.webSocketServer.clients = [];
            });
        }
        if (this.server) {
            await new Promise((resolve) => {
                this.server.close(() => {
                    this.server = undefined;
                    resolve();
                });
                for (const socket of this.sockets) {
                    socket.destroy();
                }
                this.sockets = [];
            });
            if (this.middleware) {
                await new Promise((resolve, reject) => {
                    this.middleware.close((error) => {
                        if (error) {
                            reject(error);
                            return;
                        }
                        resolve();
                    });
                });
                this.middleware = undefined;
            }
        }
        // We add listeners to signals when creating a new Server instance
        // So ensure they are removed to prevent EventEmitter memory leak warnings
        for (const item of this.listeners) {
            process.removeListener(item.name, item.listener);
        }
    }
    stopCallback(callback = () => { }) {
        this.stop()
            .then(() => callback(), callback)
            .catch(callback);
    }
}
exports.Server = Server;
