'use strict';

var errors = require('@backstage/errors');
var rest = require('@gitbeaker/rest');
var crypto = require('crypto');
var path = require('path');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefaultCompat(path);

const parseRepoHost = (repoUrl) => {
  let parsed;
  try {
    parsed = new URL(`https://${repoUrl}`);
  } catch (error) {
    throw new errors.InputError(
      `Invalid repo URL passed to publisher, got ${repoUrl}, ${error}`
    );
  }
  return parsed.host;
};
const getToken = (config, integrations) => {
  const host = parseRepoHost(config.repoUrl);
  const integrationConfig = integrations.gitlab.byHost(host);
  if (!integrationConfig) {
    throw new errors.InputError(
      `No matching integration configuration for host ${host}, please check your integrations config`
    );
  }
  const token = config.token || integrationConfig.config.token;
  return { token, integrationConfig };
};
const parseRepoUrl = (repoUrl, integrations) => {
  let parsed;
  try {
    parsed = new URL(`https://${repoUrl}`);
  } catch (error) {
    throw new errors.InputError(
      `Invalid repo URL passed to publisher, got ${repoUrl}, ${error}`
    );
  }
  const host = parsed.host;
  const owner = parsed.searchParams.get("owner") ?? void 0;
  const repo = parsed.searchParams.get("repo");
  const type = integrations.byHost(host)?.type;
  if (!type) {
    throw new errors.InputError(
      `No matching integration configuration for host ${host}, please check your integrations config`
    );
  }
  return { host, owner, repo };
};
function getClient(props) {
  const { host, token, integrations } = props;
  const integrationConfig = integrations.gitlab.byHost(host);
  if (!integrationConfig) {
    throw new errors.InputError(
      `No matching integration configuration for host ${host}, please check your integrations config`
    );
  }
  const { config } = integrationConfig;
  if (!config.token && !token) {
    throw new errors.InputError(`No token available for host ${host}`);
  }
  const requestToken = token || config.token;
  const tokenType = token ? "oauthToken" : "token";
  const gitlabOptions = {
    host: config.baseUrl
  };
  gitlabOptions[tokenType] = requestToken;
  return new rest.Gitlab(gitlabOptions);
}
function convertDate(inputDate, defaultDate) {
  try {
    return inputDate ? new Date(inputDate).toISOString() : new Date(defaultDate).toISOString();
  } catch (error) {
    throw new errors.InputError(`Error converting input date - ${error}`);
  }
}
async function getTopLevelParentGroup(client, groupId) {
  try {
    const topParentGroup = await client.Groups.show(groupId);
    if (topParentGroup.parent_id) {
      return getTopLevelParentGroup(client, topParentGroup.parent_id);
    }
    return topParentGroup;
  } catch (error) {
    throw new errors.InputError(
      `Error finding top-level parent group ID: ${error.message}`
    );
  }
}
async function checkEpicScope(client, projectId, epicId) {
  try {
    const project = await client.Projects.show(projectId);
    if (!project) {
      throw new errors.InputError(
        `Project with id ${projectId} not found. Check your GitLab instance.`
      );
    }
    const topParentGroup = await getTopLevelParentGroup(
      client,
      project.namespace.id
    );
    if (!topParentGroup) {
      throw new errors.InputError(`Couldn't find a suitable top-level parent group.`);
    }
    const epic = (await client.Epics.all(topParentGroup.id)).find(
      (x) => x.id === epicId
    );
    if (!epic) {
      throw new errors.InputError(
        `Epic with id ${epicId} not found in the top-level parent group ${topParentGroup.name}.`
      );
    }
    const epicGroup = await client.Groups.show(epic.group_id);
    const projectNamespace = project.path_with_namespace;
    return projectNamespace.startsWith(epicGroup.full_path);
  } catch (error) {
    throw new errors.InputError(`Could not find epic scope: ${error.message}`);
  }
}
function computeSha256(file) {
  const hash = crypto.createHash("sha256");
  hash.update(file.content);
  return hash.digest("hex");
}
async function getFileAction(fileInfo, target, api, logger, remoteFiles, defaultCommitAction = "auto") {
  if (defaultCommitAction === "auto") {
    const filePath = path__default.default.join(fileInfo.targetPath ?? "", fileInfo.file.path);
    if (remoteFiles?.some((remoteFile) => remoteFile.path === filePath)) {
      try {
        const targetFile = await api.RepositoryFiles.show(
          target.repoID,
          filePath,
          target.branch
        );
        if (computeSha256(fileInfo.file) === targetFile.content_sha256) {
          return "skip";
        }
      } catch (error) {
        logger.warn(
          `Unable to retrieve detailed information for remote file ${filePath}`
        );
      }
      return "update";
    }
    return "create";
  }
  return defaultCommitAction;
}

exports.checkEpicScope = checkEpicScope;
exports.convertDate = convertDate;
exports.getClient = getClient;
exports.getFileAction = getFileAction;
exports.getToken = getToken;
exports.getTopLevelParentGroup = getTopLevelParentGroup;
exports.parseRepoHost = parseRepoHost;
exports.parseRepoUrl = parseRepoUrl;
//# sourceMappingURL=util.cjs.js.map
