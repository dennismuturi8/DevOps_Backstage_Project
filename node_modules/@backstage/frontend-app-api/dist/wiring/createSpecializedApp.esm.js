import { ConfigReader } from '@backstage/config';
import { createApiFactory, appTreeApiRef, routeResolutionApiRef, ApiBlueprint } from '@backstage/frontend-plugin-api';
import { configApiRef, identityApiRef, featureFlagsApiRef } from '@backstage/core-plugin-api';
import { ApiFactoryRegistry, ApiResolver } from '@backstage/core-app-api';
import { resolveExtensionDefinition, toInternalExtension } from '../frontend-plugin-api/src/wiring/resolveExtensionDefinition.esm.js';
import { extractRouteInfoFromAppNode } from '../routing/extractRouteInfoFromAppNode.esm.js';
import { RouteResolver } from '../routing/RouteResolver.esm.js';
import { resolveRouteBindings } from '../routing/resolveRouteBindings.esm.js';
import { collectRouteIds } from '../routing/collectRouteIds.esm.js';
import { isInternalFrontendModule, toInternalFrontendModule } from '../frontend-plugin-api/src/wiring/createFrontendModule.esm.js';
import { getBasePath } from '../routing/getBasePath.esm.js';
import { Root } from '../extensions/Root.esm.js';
import { resolveAppTree } from '../tree/resolveAppTree.esm.js';
import { resolveAppNodeSpecs } from '../tree/resolveAppNodeSpecs.esm.js';
import { readAppExtensionsConfig } from '../tree/readAppExtensionsConfig.esm.js';
import { instantiateAppNodeTree } from '../tree/instantiateAppNodeTree.esm.js';
import { ApiRegistry } from '../core-app-api/src/apis/system/ApiRegistry.esm.js';
import { AppIdentityProxy } from '../core-app-api/src/apis/implementations/IdentityApi/AppIdentityProxy.esm.js';
import { matchRoutes } from 'react-router-dom';
import { createPluginInfoAttacher } from './createPluginInfoAttacher.esm.js';
import { createRouteAliasResolver } from '../routing/RouteAliasResolver.esm.js';
import { createErrorCollector } from './createErrorCollector.esm.js';
import { OpaqueFrontendPlugin } from '../frontend-internal/src/wiring/InternalFrontendPlugin.esm.js';
import { createExtensionDataContainer } from '../frontend-internal/src/wiring/createExtensionDataContainer.esm.js';

function deduplicateFeatures(allFeatures) {
  const features = Array.from(new Set(allFeatures));
  const seenIds = /* @__PURE__ */ new Set();
  return features.reverse().filter((feature) => {
    if (!OpaqueFrontendPlugin.isType(feature)) {
      return true;
    }
    if (seenIds.has(feature.id)) {
      return false;
    }
    seenIds.add(feature.id);
    return true;
  }).reverse();
}
class AppTreeApiProxy {
  #routeInfo;
  tree;
  appBasePath;
  constructor(tree, appBasePath) {
    this.tree = tree;
    this.appBasePath = appBasePath;
  }
  checkIfInitialized() {
    if (!this.#routeInfo) {
      throw new Error(
        `You can't access the AppTreeApi during initialization of the app tree. Please move occurrences of this out of the initialization of the factory`
      );
    }
  }
  getTree() {
    this.checkIfInitialized();
    return { tree: this.tree };
  }
  getNodesByRoutePath(routePath) {
    this.checkIfInitialized();
    let path = routePath;
    if (path.startsWith(this.appBasePath)) {
      path = path.slice(this.appBasePath.length);
    }
    const matchedRoutes = matchRoutes(this.#routeInfo.routeObjects, path);
    const matchedAppNodes = matchedRoutes?.filter((routeObj) => !!routeObj.route.appNode).map((routeObj) => routeObj.route.appNode) || [];
    return { nodes: matchedAppNodes };
  }
  initialize(routeInfo) {
    this.#routeInfo = routeInfo;
  }
}
class RouteResolutionApiProxy {
  #delegate;
  #routeObjects;
  routeBindings;
  appBasePath;
  constructor(routeBindings, appBasePath) {
    this.routeBindings = routeBindings;
    this.appBasePath = appBasePath;
  }
  resolve(anyRouteRef, options) {
    if (!this.#delegate) {
      throw new Error(
        `You can't access the RouteResolver during initialization of the app tree. Please move occurrences of this out of the initialization of the factory`
      );
    }
    return this.#delegate.resolve(anyRouteRef, options);
  }
  initialize(routeInfo, routeRefsById) {
    this.#delegate = new RouteResolver(
      routeInfo.routePaths,
      routeInfo.routeParents,
      routeInfo.routeObjects,
      this.routeBindings,
      this.appBasePath,
      routeInfo.routeAliasResolver,
      routeRefsById
    );
    this.#routeObjects = routeInfo.routeObjects;
    return routeInfo;
  }
  getRouteObjects() {
    return this.#routeObjects;
  }
}
function createSpecializedApp(options) {
  const config = options?.config ?? new ConfigReader({}, "empty-config");
  const features = deduplicateFeatures(options?.features ?? []).map(
    createPluginInfoAttacher(config, options?.advanced?.pluginInfoResolver)
  );
  const collector = createErrorCollector();
  const tree = resolveAppTree(
    "root",
    resolveAppNodeSpecs({
      features,
      builtinExtensions: [
        resolveExtensionDefinition(Root, { namespace: "root" })
      ],
      parameters: readAppExtensionsConfig(config),
      forbidden: /* @__PURE__ */ new Set(["root"]),
      collector
    }),
    collector
  );
  const factories = createApiFactories({ tree, collector });
  const appBasePath = getBasePath(config);
  const appTreeApi = new AppTreeApiProxy(tree, appBasePath);
  const routeRefsById = collectRouteIds(features, collector);
  const routeResolutionApi = new RouteResolutionApiProxy(
    resolveRouteBindings(options?.bindRoutes, config, routeRefsById, collector),
    appBasePath
  );
  const appIdentityProxy = new AppIdentityProxy();
  const apis = options?.advanced?.apis ?? createApiHolder({
    factories,
    staticFactories: [
      createApiFactory(appTreeApiRef, appTreeApi),
      createApiFactory(configApiRef, config),
      createApiFactory(routeResolutionApiRef, routeResolutionApi),
      createApiFactory(identityApiRef, appIdentityProxy)
    ]
  });
  const featureFlagApi = apis.get(featureFlagsApiRef);
  if (featureFlagApi) {
    for (const feature of features) {
      if (OpaqueFrontendPlugin.isType(feature)) {
        OpaqueFrontendPlugin.toInternal(feature).featureFlags.forEach(
          (flag) => featureFlagApi.registerFlag({
            name: flag.name,
            pluginId: feature.id
          })
        );
      }
      if (isInternalFrontendModule(feature)) {
        toInternalFrontendModule(feature).featureFlags.forEach(
          (flag) => featureFlagApi.registerFlag({
            name: flag.name,
            pluginId: feature.pluginId
          })
        );
      }
    }
  }
  instantiateAppNodeTree(
    tree.root,
    apis,
    collector,
    mergeExtensionFactoryMiddleware(
      options?.advanced?.extensionFactoryMiddleware
    )
  );
  const routeInfo = extractRouteInfoFromAppNode(
    tree.root,
    createRouteAliasResolver(routeRefsById)
  );
  routeResolutionApi.initialize(routeInfo, routeRefsById.routes);
  appTreeApi.initialize(routeInfo);
  return { apis, tree, errors: collector.collectErrors() };
}
function createApiFactories(options) {
  const emptyApiHolder = ApiRegistry.from([]);
  const factoriesById = /* @__PURE__ */ new Map();
  for (const apiNode of options.tree.root.edges.attachments.get("apis") ?? []) {
    if (!instantiateAppNodeTree(apiNode, emptyApiHolder, options.collector)) {
      continue;
    }
    const apiFactory = apiNode.instance?.getData(ApiBlueprint.dataRefs.factory);
    if (apiFactory) {
      const apiRefId = apiFactory.api.id;
      const ownerId = getApiOwnerId(apiRefId);
      const pluginId = apiNode.spec.plugin.id ?? "app";
      const existingFactory = factoriesById.get(apiRefId);
      if (existingFactory && existingFactory.pluginId !== pluginId) {
        const shouldReplace = ownerId === pluginId && existingFactory.pluginId !== ownerId;
        const acceptedPluginId = shouldReplace ? pluginId : existingFactory.pluginId;
        const rejectedPluginId = shouldReplace ? existingFactory.pluginId : pluginId;
        options.collector.report({
          code: "API_FACTORY_CONFLICT",
          message: `API '${apiRefId}' is already provided by plugin '${acceptedPluginId}', cannot also be provided by '${rejectedPluginId}'.`,
          context: {
            node: apiNode,
            apiRefId,
            pluginId: rejectedPluginId,
            existingPluginId: acceptedPluginId
          }
        });
        if (!shouldReplace) {
          console.warn(
            `DEPRECATION WARNING: Plugin '${rejectedPluginId}' is overriding API '${apiRefId}' from plugin '${acceptedPluginId}'. This will be blocked in a future release. Please use a module for plugin '${acceptedPluginId}' instead.`
          );
        }
      }
      factoriesById.set(apiRefId, { pluginId, factory: apiFactory });
    } else {
      options.collector.report({
        code: "API_EXTENSION_INVALID",
        message: `API extension '${apiNode.spec.id}' did not output an API factory`,
        context: {
          node: apiNode
        }
      });
    }
  }
  return Array.from(factoriesById.values(), (entry) => entry.factory);
}
function getApiOwnerId(apiRefId) {
  const [prefix, ...rest] = apiRefId.split(".");
  if (!prefix) {
    return apiRefId;
  }
  if (prefix === "core") {
    return "app";
  }
  if (prefix === "plugin" && rest[0]) {
    return rest[0];
  }
  return prefix;
}
function createApiHolder(options) {
  const factoryRegistry = new ApiFactoryRegistry();
  for (const factory of options.factories.slice().reverse()) {
    factoryRegistry.register("default", factory);
  }
  for (const factory of options.staticFactories) {
    factoryRegistry.register("static", factory);
  }
  ApiResolver.validateFactories(factoryRegistry, factoryRegistry.getAllApis());
  return new ApiResolver(factoryRegistry);
}
function mergeExtensionFactoryMiddleware(middlewares) {
  if (!middlewares) {
    return void 0;
  }
  if (!Array.isArray(middlewares)) {
    return middlewares;
  }
  if (middlewares.length <= 1) {
    return middlewares[0];
  }
  return middlewares.reduce((prev, next) => {
    if (!prev || !next) {
      return prev ?? next;
    }
    return (orig, ctx) => {
      const internalExt = toInternalExtension(ctx.node.spec.extension);
      if (internalExt.version !== "v2") {
        return orig();
      }
      return next((ctxOverrides) => {
        return createExtensionDataContainer(
          prev(orig, {
            node: ctx.node,
            apis: ctx.apis,
            config: ctxOverrides?.config ?? ctx.config
          }),
          "extension factory middleware"
        );
      }, ctx);
    };
  });
}

export { createSpecializedApp };
//# sourceMappingURL=createSpecializedApp.esm.js.map
