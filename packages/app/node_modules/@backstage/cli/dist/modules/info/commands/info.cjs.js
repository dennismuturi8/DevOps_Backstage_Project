'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _package = require('../../../packages/cli/package.json.cjs.js');
var os = require('os');
var cliCommon = require('@backstage/cli-common');
var paths = require('../../../lib/paths.cjs.js');
var Lockfile = require('../../../lib/versioning/Lockfile.cjs.js');
var minimatch = require('minimatch');
require('@manypkg/get-packages');
require('@backstage/errors');
var cliNode = require('@backstage/cli-node');
var fs = require('fs-extra');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var os__default = /*#__PURE__*/_interopDefaultCompat(os);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

function tryReadPackageJson(packageName, targetPath) {
  try {
    return require(require.resolve(`${packageName}/package.json`, {
      paths: [targetPath]
    }));
  } catch {
    return void 0;
  }
}
function hasBackstageField(packageName, targetPath) {
  const pkg = tryReadPackageJson(packageName, targetPath);
  return pkg?.backstage !== void 0;
}
var info = async (options) => {
  await new Promise(async () => {
    const yarnVersion = await cliCommon.runOutput(["yarn", "--version"]);
    const isLocal = fs__default.default.existsSync(paths.paths.resolveOwn("./src"));
    const backstageFile = paths.paths.resolveTargetRoot("backstage.json");
    let backstageVersion = "N/A";
    if (fs__default.default.existsSync(backstageFile)) {
      try {
        const backstageJson = await fs__default.default.readJSON(backstageFile);
        backstageVersion = backstageJson.version ?? "N/A";
      } catch (error) {
        if (options.format !== "json") {
          console.warn(
            'The "backstage.json" file is not in the expected format'
          );
          console.log();
        }
      }
    }
    const systemInfo = {
      os: `${os__default.default.type} ${os__default.default.release} - ${os__default.default.platform}/${os__default.default.arch}`,
      node: process.version,
      yarn: yarnVersion,
      cli: { version: _package.version, local: isLocal },
      backstage: backstageVersion
    };
    const lockfilePath = paths.paths.resolveTargetRoot("yarn.lock");
    const lockfile = await Lockfile.Lockfile.load(lockfilePath);
    const targetPath = paths.paths.targetRoot;
    const workspacePackages = /* @__PURE__ */ new Map();
    try {
      const packages = await cliNode.PackageGraph.listTargetPackages();
      for (const pkg of packages) {
        workspacePackages.set(pkg.packageJson.name, pkg.packageJson.version);
      }
    } catch {
    }
    const allPackages = [...lockfile.keys()];
    const includePatterns = options.include || [];
    const installedDeps = /* @__PURE__ */ new Set();
    const localDeps = /* @__PURE__ */ new Set();
    for (const pkg of allPackages) {
      if (pkg.startsWith("@backstage/")) {
        if (workspacePackages.has(pkg)) {
          localDeps.add(pkg);
        } else {
          installedDeps.add(pkg);
        }
      }
    }
    for (const pattern of includePatterns) {
      for (const pkg of allPackages) {
        if (minimatch.minimatch(pkg, pattern)) {
          if (workspacePackages.has(pkg)) {
            localDeps.add(pkg);
          } else {
            installedDeps.add(pkg);
          }
        }
      }
    }
    for (const pkg of allPackages) {
      if (pkg.startsWith("@backstage/")) {
        continue;
      }
      if (workspacePackages.has(pkg)) {
        if (hasBackstageField(pkg, targetPath)) {
          localDeps.add(pkg);
        }
      } else if (hasBackstageField(pkg, targetPath)) {
        installedDeps.add(pkg);
      }
    }
    const getVersions = (dep) => {
      const entries = lockfile.get(dep);
      if (!entries) {
        return [{ version: "unknown" }];
      }
      const versions = [...new Set(entries.map((i) => i.version))];
      return versions.map((v) => ({ version: v }));
    };
    const sortedInstalled = [...installedDeps].sort();
    const sortedLocal = [...localDeps].sort();
    if (options.format === "json") {
      const output = {
        system: systemInfo,
        dependencies: Object.fromEntries(
          sortedInstalled.map((dep) => [dep, getVersions(dep)])
        ),
        local: Object.fromEntries(
          sortedLocal.map((dep) => [
            dep,
            [{ version: workspacePackages.get(dep) ?? "unknown" }]
          ])
        )
      };
      process.stdout.write(`${JSON.stringify(output, null, 2)}
`);
      return;
    }
    console.log(`OS:   ${systemInfo.os}`);
    console.log(`node: ${systemInfo.node}`);
    console.log(`yarn: ${systemInfo.yarn}`);
    console.log(`cli:  ${_package.version} (${isLocal ? "local" : "installed"})`);
    console.log(`backstage:  ${backstageVersion}`);
    console.log();
    console.log("Dependencies:");
    if (sortedInstalled.length > 0) {
      const maxLength = Math.max(...sortedInstalled.map((d) => d.length));
      for (const dep of sortedInstalled) {
        const versions = getVersions(dep).map((v) => v.version).join(", ");
        console.log(`  ${dep.padEnd(maxLength)} ${versions}`);
      }
    } else {
      console.log("  (no installed Backstage packages found)");
    }
    if (localDeps.size > 0) {
      console.log();
      console.log("Local:");
      const maxLength = Math.max(...sortedLocal.map((d) => d.length));
      for (const dep of sortedLocal) {
        const version = workspacePackages.get(dep) ?? "unknown";
        console.log(`  ${dep.padEnd(maxLength)} ${version}`);
      }
    }
  });
};

exports.default = info;
//# sourceMappingURL=info.cjs.js.map
