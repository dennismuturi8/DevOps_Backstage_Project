import { useApi, errorApiRef } from '@backstage/core-plugin-api';
import { useState, useEffect } from 'react';
import useCopyToClipboard from 'react-use/esm/useCopyToClipboard';

function useLogViewerSelection(lines) {
  const errorApi = useApi(errorApiRef);
  const [selections, setSelections] = useState([]);
  const [{ error }, copyToClipboard] = useCopyToClipboard();
  useEffect(() => {
    if (error) {
      errorApi.post(error);
    }
  }, [error, errorApi]);
  const findClosestSelection = (allSelections, line) => {
    if (selections.length === 0) {
      return void 0;
    }
    let minDistance = Number.MAX_SAFE_INTEGER;
    let closestSelection = void 0;
    allSelections.forEach((s) => {
      const distance = Math.min(
        Math.abs(s.start - line),
        Math.abs(s.end - line)
      );
      if (distance < minDistance) {
        minDistance = distance;
        closestSelection = s;
      }
    });
    return closestSelection;
  };
  const mergeNeighbouringSelections = (allSelections, line) => {
    const neighboringSelections = allSelections.filter(
      (s) => s.start - 1 === line || s.end + 1 === line
    );
    if (neighboringSelections.length === 0) {
      return allSelections;
    }
    const newSelection = {
      start: Math.min(line, ...neighboringSelections.map((s) => s.start)),
      end: Math.max(line, ...neighboringSelections.map((s) => s.end))
    };
    return [
      ...allSelections.filter(
        (s) => !neighboringSelections.includes(s) && !(s.start === line && s.end === line)
      ),
      newSelection
    ];
  };
  return {
    shouldShowCopyButton(line) {
      return selections.some((s) => s.start === line);
    },
    isSelected(line) {
      if (!selections) {
        return false;
      }
      return selections.some(
        (s) => s.start <= line && (s.end ?? s.start) >= line
      );
    },
    setSelection(line, addRange, addNewSelection) {
      setSelections((currentSelections) => {
        const clickedSelection = currentSelections.find(
          (s) => s.start <= line && s.end >= line
        );
        const otherSelections = currentSelections.filter(
          (s) => s !== clickedSelection
        );
        if (!addRange && !addNewSelection) {
          if (!clickedSelection || clickedSelection.start !== clickedSelection.end) {
            return [{ start: line, end: line }];
          }
          return [];
        }
        if (addRange) {
          if (currentSelections.length === 0) {
            return [{ start: line, end: line }];
          }
          if (clickedSelection) {
            if (clickedSelection.start === clickedSelection.end) {
              return otherSelections;
            }
            return [
              ...otherSelections,
              { start: clickedSelection.start, end: line }
            ];
          }
          const closestSelection = findClosestSelection(
            currentSelections,
            line
          );
          if (!closestSelection) {
            return currentSelections;
          }
          if (closestSelection.start < line) {
            return mergeNeighbouringSelections(
              [
                ...otherSelections.filter((s) => s !== closestSelection),
                { start: closestSelection.start, end: line }
              ],
              line
            );
          }
          return mergeNeighbouringSelections(
            [
              ...otherSelections.filter((s) => s !== closestSelection),
              { start: line, end: closestSelection.end }
            ],
            line
          );
        }
        if (addNewSelection) {
          if (!clickedSelection) {
            return mergeNeighbouringSelections(
              [...currentSelections, { start: line, end: line }],
              line
            );
          }
          if (clickedSelection.start === clickedSelection.end) {
            return otherSelections;
          }
          return [
            ...otherSelections,
            ...clickedSelection.start < line ? [{ start: clickedSelection.start, end: line - 1 }] : [],
            ...clickedSelection.end > line ? [{ start: line + 1, end: clickedSelection.end }] : []
          ];
        }
        return [];
      });
    },
    copySelection(line) {
      const selection = selections.find((s) => s.start === line);
      if (!selection) {
        return;
      }
      const copyText = lines.slice(selection.start - 1, selection.end).map((l) => l.chunks.map((c) => c.text).join("")).join("\n");
      copyToClipboard(copyText);
    },
    getHash() {
      if (selections.length === 0) {
        return "";
      }
      const parts = selections.map((s) => {
        if (s.start === s.end) {
          return `${s.start}`;
        }
        return `${s.start}-${s.end}`;
      });
      return `#lines-${parts.join(",")}`;
    },
    selectAll(hash) {
      const match = hash.match(/#lines-([\d,-]+)/);
      const s = [];
      if (match) {
        const ranges = match[1].split(",");
        ranges.forEach((r) => {
          const [start, end] = r.split("-").map(Number);
          s.push({ start, end: end ?? start });
        });
      }
      setSelections(s);
    }
  };
}

export { useLogViewerSelection };
//# sourceMappingURL=useLogViewerSelection.esm.js.map
