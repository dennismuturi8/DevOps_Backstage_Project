'use strict';

var errors = require('@backstage/errors');
var paths = require('../paths.cjs.js');
var cliCommon = require('@backstage/cli-common');

async function runGit(...args) {
  try {
    const stdout = await cliCommon.runOutput(["git", ...args], {
      cwd: paths.paths.targetRoot
    });
    return stdout.trim().split(/\r\n|\r|\n/);
  } catch (error) {
    errors.assertError(error);
    if ("code" in error && typeof error.code === "number") {
      const code = error.code;
      const stderr = error.stderr;
      const msg = stderr?.trim() ?? `with exit code ${code}`;
      throw new Error(`git ${args[0]} failed, ${msg}`);
    }
    throw new errors.ForwardedError("Unknown execution error", error);
  }
}
class GitUtils {
  /**
   * Returns a sorted list of all files that have changed since the merge base
   * of the provided `ref` and HEAD, as well as all files that are not tracked by git.
   */
  static async listChangedFiles(ref) {
    if (!ref) {
      throw new Error("ref is required");
    }
    let diffRef = ref;
    try {
      const [base] = await runGit("merge-base", "HEAD", ref);
      diffRef = base;
    } catch {
    }
    const tracked = await runGit("diff", "--name-only", diffRef);
    const untracked = await runGit(
      "ls-files",
      "--others",
      "--exclude-standard"
    );
    return Array.from(/* @__PURE__ */ new Set([...tracked, ...untracked]));
  }
  /**
   * Returns the contents of a file at a specific ref.
   */
  static async readFileAtRef(path, ref) {
    let showRef = ref;
    try {
      const [base] = await runGit("merge-base", "HEAD", ref);
      showRef = base;
    } catch {
    }
    const stdout = await cliCommon.runOutput(["git", "show", `${showRef}:${path}`], {
      cwd: paths.paths.targetRoot
    });
    return stdout;
  }
}

exports.GitUtils = GitUtils;
exports.runGit = runGit;
//# sourceMappingURL=GitUtils.cjs.js.map
