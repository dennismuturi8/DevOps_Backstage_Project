/**
 * The following code is modified based on
 * https://github.com/webpack/webpack-dev-server
 *
 * MIT Licensed
 * Author Tobias Koppers @sokra
 * Copyright (c) JS Foundation and other contributors
 * https://github.com/webpack/webpack-dev-server/blob/main/LICENSE
 */
/// <reference types="express" />
/// <reference types="node" />
/// <reference types="connect-history-api-fallback" />
/// <reference types="node" />
import type { BasicApplication, ExpressApplication, HTTPServer, Response, Request, Host, Port, DevMiddlewareOptions, ConnectHistoryApiFallbackOptions, BonjourOptions, WatchFiles, Static, ServerType, ServerConfiguration, WebSocketServerConfiguration, ProxyConfigArray, Open, ClientConfiguration, Middleware, DevMiddlewareContext, Compiler, MultiCompiler, FSWatcher, EXPECTED_ANY, RequestHandler, Socket, Bonjour, WebSocketServerImplementation, Stats, MultiStats, DevServer, Schema, StatsOptions, WatchOptions, StatsCompilation, NextFunction, ClientConnection, Headers } from './types';
export interface Configuration<A extends BasicApplication = ExpressApplication, S extends HTTPServer = HTTPServer> {
    ipc?: boolean | string;
    host?: Host;
    port?: Port;
    hot?: boolean | 'only';
    liveReload?: boolean;
    devMiddleware?: DevMiddlewareOptions<Request, Response>;
    compress?: boolean;
    allowedHosts?: 'auto' | 'all' | string | string[];
    historyApiFallback?: boolean | ConnectHistoryApiFallbackOptions;
    bonjour?: boolean | Record<string, never> | BonjourOptions;
    watchFiles?: string | string[] | WatchFiles | Array<string | WatchFiles>;
    static?: boolean | string | Static | Array<string | Static>;
    server?: ServerType<A, S> | ServerConfiguration<A, S>;
    app?: () => Promise<A>;
    webSocketServer?: boolean | 'sockjs' | 'ws' | string | WebSocketServerConfiguration;
    proxy?: ProxyConfigArray;
    open?: boolean | string | Open | Array<string | Open>;
    setupExitSignals?: boolean;
    client?: boolean | ClientConfiguration;
    headers?: Headers | ((req: Request, res: Response, context: DevMiddlewareContext<Request, Response> | undefined) => Headers);
    onListening?: (devServer: Server<A, S>) => void;
    setupMiddlewares?: (middlewares: Middleware[], devServer: Server<A, S>) => Middleware[];
}
declare class Server<A extends BasicApplication = ExpressApplication, S extends import('http').Server = HTTPServer> {
    compiler: Compiler | MultiCompiler;
    logger: ReturnType<Compiler['getInfrastructureLogger']>;
    options: Configuration<A, S>;
    staticWatchers: FSWatcher[];
    listeners: {
        name: string | symbol;
        listener: (...args: EXPECTED_ANY[]) => void;
    }[];
    webSocketProxies: RequestHandler[];
    sockets: Socket[];
    currentHash: string | undefined;
    isTlsServer: boolean;
    bonjour: Bonjour | undefined;
    webSocketServer: WebSocketServerImplementation | null | undefined;
    middleware: import('webpack-dev-middleware').API<Request, Response> | undefined;
    server: S | undefined;
    app: A | undefined;
    stats: Stats | MultiStats | undefined;
    constructor(options: DevServer, compiler: Compiler | MultiCompiler);
    static get schema(): Schema;
    static get DEFAULT_STATS(): StatsOptions;
    static isAbsoluteURL(URL: string): boolean;
    static findIp(gatewayOrFamily: string, isInternal: boolean): string | undefined;
    static internalIP(family: 'v4' | 'v6'): Promise<string | undefined>;
    static internalIPSync(family: 'v4' | 'v6'): string | undefined;
    static getHostname(hostname: Host): Promise<string>;
    static getFreePort(port: string, host: string): Promise<any>;
    static findCacheDir(): string;
    static isWebTarget(compiler: Compiler): boolean;
    addAdditionalEntries(compiler: Compiler): void;
    /**
     * @private
     * @returns {Compiler["options"]} compiler options
     */
    getCompilerOptions(): import("@rspack/core").RspackOptionsNormalized;
    normalizeOptions(): Promise<void>;
    /**
     * @private
     * @returns {string} client transport
     */
    getClientTransport(): string;
    getServerTransport(): typeof import("./servers/SockJSServer") | typeof import("./servers/WebsocketServer") | undefined;
    getClientEntry(): string;
    getClientHotEntry(): string | undefined;
    setupProgressPlugin(): void;
    /**
     * @private
     * @returns {Promise<void>}
     */
    initialize(): Promise<void>;
    setupApp(): Promise<void>;
    getStats(statsObj: Stats | MultiStats): StatsCompilation;
    setupHooks(): void;
    setupWatchStaticFiles(): void;
    setupWatchFiles(): void;
    setupMiddlewares(): void;
    /**
     * @private
     * @returns {Promise<void>}
     */
    createServer(): Promise<void>;
    createWebSocketServer(): void;
    openBrowser(defaultOpenTarget: string): Promise<void>;
    runBonjour(): void;
    stopBonjour(callback?: () => void): void;
    logStatus(): Promise<void>;
    setHeaders(req: Request, res: Response, next: NextFunction): void;
    isHostAllowed(value: string): boolean;
    isValidHost(headers: Record<string, string | undefined>, headerToCheck: string, validateHost?: boolean): boolean;
    isSameOrigin(headers: Record<string, string | undefined>): boolean;
    sendMessage(clients: ClientConnection[], type: string, data?: EXPECTED_ANY, params?: EXPECTED_ANY): void;
    sendStats(clients: ClientConnection[], stats: StatsCompilation, force?: boolean): void;
    watchFiles(watchPath: string | string[], watchOptions?: WatchOptions): void;
    invalidate(callback?: import('webpack-dev-middleware').Callback): void;
    start(): Promise<void>;
    startCallback(callback?: (err?: Error) => void): void;
    stop(): Promise<void>;
    stopCallback(callback?: (err?: Error) => void): void;
}
export { Server };
