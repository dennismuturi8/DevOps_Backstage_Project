import { jsx } from 'react/jsx-runtime';
import { useMemo } from 'react';
import { getOrCreateGlobalSingleton, useVersionedContext } from '@backstage/version-bridge';
import { appTreeApiRef, iconsApiRef, Progress, NotFoundErrorPage, useApiHolder, ErrorDisplay, createFrontendPlugin } from '@backstage/frontend-plugin-api';

const legacyPluginStore = getOrCreateGlobalSingleton(
  "legacy-plugin-compatibility-store",
  () => /* @__PURE__ */ new WeakMap()
);
function toLegacyPlugin(plugin) {
  let legacy = legacyPluginStore.get(plugin);
  if (legacy) {
    return legacy;
  }
  const errorMsg = "Not implemented in legacy plugin compatibility layer";
  const notImplemented = () => {
    throw new Error(errorMsg);
  };
  legacy = {
    getId() {
      return plugin.id;
    },
    get routes() {
      return {};
    },
    get externalRoutes() {
      return {};
    },
    getApis: notImplemented,
    getFeatureFlags: notImplemented,
    provide: notImplemented
  };
  legacyPluginStore.set(plugin, legacy);
  return legacy;
}
function toNewPlugin(plugin) {
  return createFrontendPlugin({
    pluginId: plugin.getId()
  });
}
function useOptionalApiHolder() {
  try {
    return useApiHolder();
  } catch {
    return void 0;
  }
}
const useApp = () => {
  const apiHolder = useOptionalApiHolder();
  const appTreeApi = apiHolder?.get(appTreeApiRef);
  const iconsApi = apiHolder?.get(iconsApiRef);
  const versionedContext = useVersionedContext(
    "app-context"
  );
  const newAppContext = useMemo(() => {
    if (!appTreeApi) {
      return void 0;
    }
    if (!iconsApi) {
      return void 0;
    }
    const { tree } = appTreeApi.getTree();
    let gatheredPlugins = void 0;
    const ErrorBoundaryFallbackWrapper = ({ plugin, ...rest }) => /* @__PURE__ */ jsx(ErrorDisplay, { ...rest, plugin: plugin && toNewPlugin(plugin) });
    return {
      getPlugins() {
        if (gatheredPlugins) {
          return gatheredPlugins;
        }
        const pluginSet = /* @__PURE__ */ new Set();
        for (const node of tree.nodes.values()) {
          const plugin = node.spec.plugin;
          if (plugin) {
            pluginSet.add(toLegacyPlugin(plugin));
          }
        }
        gatheredPlugins = Array.from(pluginSet);
        return gatheredPlugins;
      },
      getSystemIcon(key) {
        return iconsApi.getIcon(key);
      },
      getSystemIcons() {
        return Object.fromEntries(
          iconsApi.listIconKeys().map((key) => [key, iconsApi.getIcon(key)])
        );
      },
      getComponents() {
        return {
          NotFoundErrorPage,
          BootErrorPage() {
            throw new Error(
              "The BootErrorPage app component should not be accessed by plugins"
            );
          },
          Progress,
          Router() {
            throw new Error(
              "The Router app component should not be accessed by plugins"
            );
          },
          ErrorBoundaryFallback: ErrorBoundaryFallbackWrapper
        };
      }
    };
  }, [appTreeApi, iconsApi]);
  if (newAppContext) {
    return newAppContext;
  }
  if (!versionedContext) {
    throw new Error("App context is not available");
  }
  const appContext = versionedContext.atVersion(1);
  if (!appContext) {
    throw new Error("AppContext v1 not available");
  }
  return appContext;
};

export { useApp };
//# sourceMappingURL=useApp.esm.js.map
