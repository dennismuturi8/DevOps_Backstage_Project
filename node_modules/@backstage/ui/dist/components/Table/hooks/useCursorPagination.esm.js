import { useState, useCallback } from 'react';
import { usePageCache } from './usePageCache.esm.js';
import { useStableCallback } from './useStableCallback.esm.js';
import { useDebouncedReload } from './useDebouncedReload.esm.js';
import { getEffectivePageSize } from './getEffectivePageSize.esm.js';

function useCursorPagination(options, query) {
  const { getData: getDataProp, paginationOptions = {} } = options;
  const defaultPageSize = getEffectivePageSize(paginationOptions);
  const getData = useStableCallback(getDataProp);
  const { sort, filter, search } = query;
  const [pageSize, setPageSize] = useState(defaultPageSize);
  const wrappedGetData = useCallback(
    async ({
      cursor,
      signal
    }) => {
      const params = {
        cursor,
        pageSize,
        sort,
        filter,
        search,
        signal
      };
      const response = await getData(params);
      return {
        data: response.data,
        prevCursor: response.prevCursor,
        nextCursor: response.nextCursor,
        totalCount: response.totalCount
      };
    },
    [getData, pageSize, sort, filter, search]
  );
  const cache = usePageCache({ getData: wrappedGetData });
  useDebouncedReload(query, pageSize, cache.reload);
  const onPageSizeChange = useCallback(
    (newSize) => setPageSize(newSize),
    []
  );
  return {
    data: cache.data,
    loading: cache.loading,
    error: cache.error,
    totalCount: cache.totalCount,
    offset: void 0,
    pageSize,
    hasNextPage: cache.hasNextPage,
    hasPreviousPage: cache.hasPreviousPage,
    onNextPage: cache.onNextPage,
    onPreviousPage: cache.onPreviousPage,
    onPageSizeChange,
    reload: cache.reload
  };
}

export { useCursorPagination };
//# sourceMappingURL=useCursorPagination.esm.js.map
