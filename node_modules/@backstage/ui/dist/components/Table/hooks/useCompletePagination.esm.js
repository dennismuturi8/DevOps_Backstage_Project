import { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { useStableCallback } from './useStableCallback.esm.js';
import { getEffectivePageSize } from './getEffectivePageSize.esm.js';

function useCompletePagination(options, query) {
  const {
    getData: getDataProp,
    paginationOptions = {},
    sortFn,
    filterFn,
    searchFn
  } = options;
  const { initialOffset = 0 } = paginationOptions;
  const defaultPageSize = getEffectivePageSize(paginationOptions);
  const getData = useStableCallback(getDataProp);
  const { sort, filter, search } = query;
  const [items, setItems] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(void 0);
  const [loadCount, setLoadCount] = useState(0);
  const [offset, setOffset] = useState(initialOffset);
  const [pageSize, setPageSize] = useState(defaultPageSize);
  useEffect(() => {
    let cancelled = false;
    setIsLoading(true);
    setError(void 0);
    (async () => {
      try {
        const result = getData();
        const data = result instanceof Promise ? await result : result;
        if (!cancelled) {
          setItems(data);
          setIsLoading(false);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err instanceof Error ? err : new Error(String(err)));
          setIsLoading(false);
        }
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [getData, loadCount]);
  const prevQueryRef = useRef(query);
  useEffect(() => {
    if (prevQueryRef.current !== query) {
      prevQueryRef.current = query;
      setOffset(0);
    }
  }, [query]);
  const processedData = useMemo(() => {
    let result = [...items];
    if (filter !== void 0 && filterFn) {
      result = filterFn(result, filter);
    }
    if (search && searchFn) {
      result = searchFn(result, search);
    }
    if (sort && sortFn) {
      result = sortFn(result, sort);
    }
    return result;
  }, [items, sort, filter, search, filterFn, searchFn, sortFn]);
  const totalCount = processedData.length;
  const paginatedData = useMemo(
    () => processedData.slice(offset, offset + pageSize),
    [processedData, offset, pageSize]
  );
  const hasNextPage = offset + pageSize < totalCount;
  const hasPreviousPage = offset > 0;
  const onNextPage = useCallback(() => {
    if (offset + pageSize < totalCount) {
      setOffset(offset + pageSize);
    }
  }, [offset, pageSize, totalCount]);
  const onPreviousPage = useCallback(() => {
    if (offset > 0) {
      setOffset(Math.max(0, offset - pageSize));
    }
  }, [offset, pageSize]);
  const onPageSizeChange = useCallback((newSize) => {
    setPageSize(newSize);
    setOffset(0);
  }, []);
  const reload = useCallback(() => {
    setOffset(0);
    setLoadCount((c) => c + 1);
  }, []);
  return {
    data: paginatedData,
    loading: isLoading,
    error,
    totalCount,
    offset,
    pageSize,
    hasNextPage,
    hasPreviousPage,
    onNextPage,
    onPreviousPage,
    onPageSizeChange,
    reload
  };
}

export { useCompletePagination };
//# sourceMappingURL=useCompletePagination.esm.js.map
