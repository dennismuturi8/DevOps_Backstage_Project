'use strict';

var errors = require('@backstage/errors');
var platformPath = require('path');
var ReadUrlResponseFactory = require('./ReadUrlResponseFactory.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var platformPath__default = /*#__PURE__*/_interopDefaultCompat(platformPath);

const REDIRECT_STATUS_CODES = [301, 302, 307, 308];
const MAX_REDIRECTS = 5;
const isInRange = (num, [start, end]) => {
  return num >= start && num <= end;
};
const parsePortRange = (port) => {
  const isRange = port.includes("-");
  if (isRange) {
    const range = port.split("-").map((v) => parseInt(v, 10)).filter(Boolean);
    if (range.length !== 2) throw new Error(`Port range is not valid: ${port}`);
    const [start, end] = range;
    if (start <= 0 || end <= 0 || start > end)
      throw new Error(`Port range is not valid: [${start}, ${end}]`);
    return range;
  }
  const parsedPort = parseInt(port, 10);
  return [parsedPort, parsedPort];
};
const parsePortPredicate = (port) => {
  if (port) {
    const range = parsePortRange(port);
    return (url) => {
      if (url.port) return isInRange(parseInt(url.port, 10), range);
      if (url.protocol === "http:") return isInRange(80, range);
      if (url.protocol === "https:") return isInRange(443, range);
      return false;
    };
  }
  return (url) => !url.port;
};
function predicateFromConfig(config) {
  const allow = config.getOptionalConfigArray("backend.reading.allow")?.map((allowConfig) => {
    const paths = allowConfig.getOptionalStringArray("paths");
    const checkPath = paths ? (url) => {
      const targetPath = platformPath__default.default.posix.normalize(url.pathname);
      return paths.some(
        (allowedPath) => targetPath.startsWith(allowedPath)
      );
    } : (_url) => true;
    const host = allowConfig.getString("host");
    const [hostname, port] = host.split(":");
    const checkPort = parsePortPredicate(port);
    if (hostname.startsWith("*.")) {
      const suffix = hostname.slice(1);
      return (url) => url.hostname.endsWith(suffix) && checkPath(url) && checkPort(url);
    }
    return (url) => url.hostname === hostname && checkPath(url) && checkPort(url);
  });
  return allow?.length ? (url) => allow.some((p) => p(url)) : () => false;
}
class FetchUrlReader {
  /**
   * The factory creates a single reader that will be used for reading any URL that's listed
   * in configuration at `backend.reading.allow`. The allow list contains a list of objects describing
   * targets to allow, containing the following fields:
   *
   * `host`:
   *   Either full hostnames to match, or subdomain wildcard matchers with a leading '*'.
   *   For example 'example.com' and '*.example.com' are valid values, 'prod.*.example.com' is not.
   *
   * `paths`:
   *   An optional list of paths which are allowed. If the list is omitted all paths are allowed.
   */
  static factory = ({ config }) => {
    const predicate = predicateFromConfig(config);
    const reader = new FetchUrlReader({ predicate });
    return [{ reader, predicate }];
  };
  static fromConfig(config) {
    return new FetchUrlReader({ predicate: predicateFromConfig(config) });
  }
  #predicate;
  constructor(options) {
    this.#predicate = options.predicate;
  }
  async read(url) {
    const response = await this.readUrl(url);
    return response.buffer();
  }
  async readUrl(url, options) {
    let currentUrl = url;
    for (let redirectCount = 0; redirectCount < MAX_REDIRECTS; redirectCount += 1) {
      const parsedUrl = new URL(currentUrl);
      if (!this.#predicate(parsedUrl)) {
        throw new Error(
          `URL not allowed by backend.reading.allow configuration: ${currentUrl}`
        );
      }
      let response;
      try {
        response = await fetch(currentUrl, {
          headers: {
            ...options?.etag && { "If-None-Match": options.etag },
            ...options?.lastModifiedAfter && {
              "If-Modified-Since": options.lastModifiedAfter.toUTCString()
            },
            ...options?.token && { Authorization: `Bearer ${options.token}` }
          },
          // Handle redirects manually to validate targets against the allowlist
          redirect: "manual",
          // TODO(freben): The signal cast is there because pre-3.x versions of
          // node-fetch have a very slightly deviating AbortSignal type signature.
          // The difference does not affect us in practice however. The cast can
          // be removed after we support ESM for CLI dependencies and migrate to
          // version 3 of node-fetch.
          // https://github.com/backstage/backstage/issues/8242
          signal: options?.signal
        });
      } catch (e) {
        throw new Error(`Unable to read ${currentUrl}, ${e}`);
      }
      if (response.ok) {
        return ReadUrlResponseFactory.ReadUrlResponseFactory.fromResponse(response);
      }
      if (response.status === 304) {
        throw new errors.NotModifiedError();
      }
      const location = response.headers.get("location");
      if (!REDIRECT_STATUS_CODES.includes(response.status) || !location) {
        const message = `could not read ${currentUrl}, ${response.status} ${response.statusText}`;
        if (response.status === 404) {
          throw new errors.NotFoundError(message);
        }
        throw new Error(message);
      }
      currentUrl = new URL(location, currentUrl).toString();
    }
    throw new Error(
      `Too many redirects (max ${MAX_REDIRECTS}) when reading ${url}`
    );
  }
  async readTree() {
    throw new Error("FetchUrlReader does not implement readTree");
  }
  async search(url, options) {
    const { pathname } = new URL(url);
    if (pathname.match(/[*?]/)) {
      throw new Error("Unsupported search pattern URL");
    }
    try {
      const data = await this.readUrl(url, options);
      return {
        files: [
          {
            url,
            content: data.buffer,
            lastModifiedAt: data.lastModifiedAt
          }
        ],
        etag: data.etag ?? ""
      };
    } catch (error) {
      errors.assertError(error);
      if (error.name === "NotFoundError") {
        return {
          files: [],
          etag: ""
        };
      }
      throw error;
    }
  }
  toString() {
    return "fetch{}";
  }
}

exports.FetchUrlReader = FetchUrlReader;
//# sourceMappingURL=FetchUrlReader.cjs.js.map
