{"version":3,"file":"useRouteRef.esm.js","sources":["../../src/routing/useRouteRef.tsx"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { useMemo } from 'react';\nimport { matchRoutes, useLocation } from 'react-router-dom';\nimport { useVersionedContext } from '@backstage/version-bridge';\nimport {\n  RouteResolutionApi,\n  routeResolutionApiRef,\n  useApi,\n} from '@backstage/frontend-plugin-api';\nimport {\n  AnyParams,\n  ExternalRouteRef,\n  RouteFunc,\n  RouteRef,\n  SubRouteRef,\n} from './types';\n\n/**\n * @internal\n */\nexport interface RouteResolver {\n  resolve<Params extends AnyParams>(\n    anyRouteRef:\n      | RouteRef<Params>\n      | SubRouteRef<Params>\n      | ExternalRouteRef<Params, any>,\n    sourceLocation: Parameters<typeof matchRoutes>[1],\n  ): RouteFunc<Params> | undefined;\n}\n\nfunction useRouteResolutionApi(): RouteResolutionApi | undefined {\n  try {\n    return useApi(routeResolutionApiRef);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * React hook for constructing URLs to routes.\n *\n * @remarks\n *\n * See {@link https://backstage.io/docs/plugins/composability#routing-system}\n *\n * @param routeRef - The ref to route that should be converted to URL.\n * @returns A function that will in turn return the concrete URL of the `routeRef`.\n * @public\n */\nexport function useRouteRef<Optional extends boolean, Params extends AnyParams>(\n  routeRef: ExternalRouteRef<Params, Optional>,\n): Optional extends true ? RouteFunc<Params> | undefined : RouteFunc<Params>;\n\n/**\n * React hook for constructing URLs to routes.\n *\n * @remarks\n *\n * See {@link https://backstage.io/docs/plugins/composability#routing-system}\n *\n * @param routeRef - The ref to route that should be converted to URL.\n * @returns A function that will in turn return the concrete URL of the `routeRef`.\n * @public\n */\nexport function useRouteRef<Params extends AnyParams>(\n  routeRef: RouteRef<Params> | SubRouteRef<Params>,\n): RouteFunc<Params>;\n\n/**\n * React hook for constructing URLs to routes.\n *\n * @remarks\n *\n * See {@link https://backstage.io/docs/plugins/composability#routing-system}\n *\n * @param routeRef - The ref to route that should be converted to URL.\n * @returns A function that will in turn return the concrete URL of the `routeRef`.\n * @public\n */\nexport function useRouteRef<Params extends AnyParams>(\n  routeRef:\n    | RouteRef<Params>\n    | SubRouteRef<Params>\n    | ExternalRouteRef<Params, any>,\n): RouteFunc<Params> | undefined {\n  const { pathname } = useLocation();\n  const routeResolutionApi = useRouteResolutionApi();\n  const versionedContext = useVersionedContext<{ 1: RouteResolver }>(\n    'routing-context',\n  );\n\n  const resolver = versionedContext?.atVersion(1);\n\n  const newRouteFunc = useMemo(() => {\n    if (!routeResolutionApi) {\n      return null;\n    }\n\n    try {\n      return routeResolutionApi?.resolve(routeRef, {\n        sourcePath: pathname,\n      });\n    } catch {\n      return null;\n    }\n  }, [routeResolutionApi, routeRef, pathname]);\n\n  const legacyRouteFunc = useMemo(\n    () => resolver && resolver.resolve(routeRef, { pathname }),\n    [resolver, routeRef, pathname],\n  );\n\n  if (newRouteFunc !== null) {\n    const isOptional = 'optional' in routeRef && routeRef.optional;\n    if (!newRouteFunc && !isOptional) {\n      throw new Error(`No path for ${routeRef}`);\n    }\n    return newRouteFunc;\n  }\n\n  if (!versionedContext) {\n    throw new Error('Routing context is not available');\n  }\n\n  if (!resolver) {\n    throw new Error('RoutingContext v1 not available');\n  }\n\n  const isOptional = 'optional' in routeRef && routeRef.optional;\n  if (!legacyRouteFunc && !isOptional) {\n    throw new Error(`No path for ${routeRef}`);\n  }\n\n  return legacyRouteFunc;\n}\n"],"names":["isOptional"],"mappings":";;;;;AA6CA,SAAS,qBAAA,GAAwD;AAC/D,EAAA,IAAI;AACF,IAAA,OAAO,OAAO,qBAAqB,CAAA;AAAA,EACrC,CAAA,CAAA,MAAQ;AACN,IAAA,OAAO,MAAA;AAAA,EACT;AACF;AA2CO,SAAS,YACd,QAAA,EAI+B;AAC/B,EAAA,MAAM,EAAE,QAAA,EAAS,GAAI,WAAA,EAAY;AACjC,EAAA,MAAM,qBAAqB,qBAAA,EAAsB;AACjD,EAAA,MAAM,gBAAA,GAAmB,mBAAA;AAAA,IACvB;AAAA,GACF;AAEA,EAAA,MAAM,QAAA,GAAW,gBAAA,EAAkB,SAAA,CAAU,CAAC,CAAA;AAE9C,EAAA,MAAM,YAAA,GAAe,QAAQ,MAAM;AACjC,IAAA,IAAI,CAAC,kBAAA,EAAoB;AACvB,MAAA,OAAO,IAAA;AAAA,IACT;AAEA,IAAA,IAAI;AACF,MAAA,OAAO,kBAAA,EAAoB,QAAQ,QAAA,EAAU;AAAA,QAC3C,UAAA,EAAY;AAAA,OACb,CAAA;AAAA,IACH,CAAA,CAAA,MAAQ;AACN,MAAA,OAAO,IAAA;AAAA,IACT;AAAA,EACF,CAAA,EAAG,CAAC,kBAAA,EAAoB,QAAA,EAAU,QAAQ,CAAC,CAAA;AAE3C,EAAA,MAAM,eAAA,GAAkB,OAAA;AAAA,IACtB,MAAM,QAAA,IAAY,QAAA,CAAS,QAAQ,QAAA,EAAU,EAAE,UAAU,CAAA;AAAA,IACzD,CAAC,QAAA,EAAU,QAAA,EAAU,QAAQ;AAAA,GAC/B;AAEA,EAAA,IAAI,iBAAiB,IAAA,EAAM;AACzB,IAAA,MAAMA,WAAAA,GAAa,UAAA,IAAc,QAAA,IAAY,QAAA,CAAS,QAAA;AACtD,IAAA,IAAI,CAAC,YAAA,IAAgB,CAACA,WAAAA,EAAY;AAChC,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,YAAA,EAAe,QAAQ,CAAA,CAAE,CAAA;AAAA,IAC3C;AACA,IAAA,OAAO,YAAA;AAAA,EACT;AAEA,EAAA,IAAI,CAAC,gBAAA,EAAkB;AACrB,IAAA,MAAM,IAAI,MAAM,kCAAkC,CAAA;AAAA,EACpD;AAEA,EAAA,IAAI,CAAC,QAAA,EAAU;AACb,IAAA,MAAM,IAAI,MAAM,iCAAiC,CAAA;AAAA,EACnD;AAEA,EAAA,MAAM,UAAA,GAAa,UAAA,IAAc,QAAA,IAAY,QAAA,CAAS,QAAA;AACtD,EAAA,IAAI,CAAC,eAAA,IAAmB,CAAC,UAAA,EAAY;AACnC,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,YAAA,EAAe,QAAQ,CAAA,CAAE,CAAA;AAAA,EAC3C;AAEA,EAAA,OAAO,eAAA;AACT;;;;"}