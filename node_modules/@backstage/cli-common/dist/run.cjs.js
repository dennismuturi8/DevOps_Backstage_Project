'use strict';

var spawn = require('cross-spawn');
var errors = require('./errors.cjs.js');
var errors$1 = require('@backstage/errors');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var spawn__default = /*#__PURE__*/_interopDefaultCompat(spawn);

function run(args, options = {}) {
  if (args.length === 0) {
    throw new Error("run requires at least one argument");
  }
  const [name, ...cmdArgs] = args;
  const { onStdout, onStderr, stdio: customStdio, ...spawnOptions } = options;
  const env = {
    ...process.env,
    FORCE_COLOR: "true",
    ...options.env ?? {}
  };
  const stdio = customStdio ?? [
    "inherit",
    onStdout ? "pipe" : "inherit",
    onStderr ? "pipe" : "inherit"
  ];
  const child = spawn__default.default(name, cmdArgs, {
    ...spawnOptions,
    stdio,
    env
  });
  if (onStdout && child.stdout) {
    child.stdout.on("data", onStdout);
  }
  if (onStderr && child.stderr) {
    child.stderr.on("data", onStderr);
  }
  const commandName = args.join(" ");
  let waitPromise;
  child.waitForExit = async () => {
    if (waitPromise) {
      return waitPromise;
    }
    waitPromise = new Promise((resolve, reject) => {
      if (typeof child.exitCode === "number") {
        if (child.exitCode) {
          reject(new errors.ExitCodeError(child.exitCode, commandName));
        } else {
          resolve();
        }
        return;
      }
      function onError(error) {
        cleanup();
        reject(error);
      }
      function onExit(code) {
        cleanup();
        if (code) {
          reject(new errors.ExitCodeError(code, commandName));
        } else {
          resolve();
        }
      }
      function onSignal() {
        if (!child.killed && child.exitCode === null) {
          child.kill();
        }
      }
      function cleanup() {
        for (const signal of ["SIGINT", "SIGTERM"]) {
          process.removeListener(signal, onSignal);
        }
        child.removeListener("error", onError);
        child.removeListener("exit", onExit);
      }
      child.once("error", onError);
      child.once("exit", onExit);
      for (const signal of ["SIGINT", "SIGTERM"]) {
        process.addListener(signal, onSignal);
      }
    });
    return waitPromise;
  };
  return child;
}
async function runOutput(args, options) {
  const stdoutChunks = [];
  const stderrChunks = [];
  if (args.length === 0) {
    throw new Error("runOutput requires at least one argument");
  }
  try {
    await run(args, {
      ...options,
      onStdout: (data) => {
        stdoutChunks.push(data);
        options?.onStdout?.(data);
      },
      onStderr: (data) => {
        stderrChunks.push(data);
        options?.onStderr?.(data);
      }
    }).waitForExit();
    return Buffer.concat(stdoutChunks).toString().trim();
  } catch (error) {
    errors$1.assertError(error);
    error.stdout = Buffer.concat(stdoutChunks).toString();
    error.stderr = Buffer.concat(stderrChunks).toString();
    throw error;
  }
}
async function runCheck(args) {
  try {
    await run(args).waitForExit();
    return true;
  } catch {
    return false;
  }
}

exports.run = run;
exports.runCheck = runCheck;
exports.runOutput = runOutput;
//# sourceMappingURL=run.cjs.js.map
