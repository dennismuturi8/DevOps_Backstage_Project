import * as react from 'react';
import { ReactElement, ReactNode, ElementType, ComponentPropsWithRef, ComponentProps } from 'react';
import { ButtonProps as ButtonProps$1, DisclosureProps, HeadingProps, DisclosurePanelProps, DisclosureGroupProps, DialogTriggerProps as DialogTriggerProps$1, ModalOverlayProps, TabsProps as TabsProps$1, TabListProps as TabListProps$1, TabProps as TabProps$1, TabPanelProps as TabPanelProps$1, LinkProps as LinkProps$1, CheckboxProps as CheckboxProps$1, RadioGroupProps as RadioGroupProps$1, RadioProps as RadioProps$1, TableProps as TableProps$1, ColumnProps as ColumnProps$1, CellProps as CellProps$1, TableHeaderProps, TableBodyProps, RowProps, TagGroupProps as TagGroupProps$1, TagListProps, TagProps as TagProps$1, TextFieldProps as TextFieldProps$1, TooltipProps as TooltipProps$1, TooltipTriggerComponentProps, MenuTriggerProps as MenuTriggerProps$1, SubmenuTriggerProps as SubmenuTriggerProps$1, MenuProps as MenuProps$1, PopoverProps as PopoverProps$1, ListBoxProps, MenuItemProps as MenuItemProps$1, ListBoxItemProps, MenuSectionProps as MenuSectionProps$1, SeparatorProps, SearchFieldProps as SearchFieldProps$1, SelectProps as SelectProps$1, SwitchProps as SwitchProps$1, ToggleButtonProps as ToggleButtonProps$1, ToggleButtonGroupProps as ToggleButtonGroupProps$1 } from 'react-aria-components';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { NavigateOptions } from 'react-router-dom';
import { SortDescriptor as SortDescriptor$1 } from 'react-stately';
import { ColumnSize, ColumnStaticSize } from '@react-types/table';

/** @public */
type Breakpoint = 'initial' | 'xs' | 'sm' | 'md' | 'lg' | 'xl';
/** @public */
type Responsive<T> = T | Partial<Record<Breakpoint, T>>;
/** @public */
type Space = '0.5' | '1' | '1.5' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | string;
/** @public */
type Display = 'none' | 'flex' | 'block' | 'inline';
/** @public */
type FlexDirection = 'row' | 'column';
/** @public */
type FlexWrap = 'wrap' | 'nowrap' | 'wrap-reverse';
/** @public */
type JustifyContent = 'stretch' | 'start' | 'center' | 'end' | 'around' | 'between';
/** @public */
type AlignItems = 'stretch' | 'start' | 'center' | 'end';
/** @public */
type BorderRadius = 'none' | '2xs' | 'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl';
/** @public */
type Border = 'none' | 'base' | 'error' | 'warning' | 'selected';
/** @public */
type Columns = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | 'auto';
/** @public */
interface SpaceProps {
    m?: Responsive<Space>;
    mb?: Responsive<Space>;
    ml?: Responsive<Space>;
    mr?: Responsive<Space>;
    mt?: Responsive<Space>;
    mx?: Responsive<Space>;
    my?: Responsive<Space>;
    p?: Responsive<Space>;
    pb?: Responsive<Space>;
    pl?: Responsive<Space>;
    pr?: Responsive<Space>;
    pt?: Responsive<Space>;
    px?: Responsive<Space>;
    py?: Responsive<Space>;
}
/** @public */
type TextVariants = 'title-large' | 'title-medium' | 'title-small' | 'title-x-small' | 'body-large' | 'body-medium' | 'body-small' | 'body-x-small';
/** @public */
type TextColors = 'primary' | 'secondary';
/** @public */
type TextColorStatus = 'danger' | 'warning' | 'success';
/** @public */
type TextWeights = 'regular' | 'bold';
/** @public */
interface UtilityProps extends SpaceProps {
    alignItems?: Responsive<AlignItems>;
    border?: Responsive<Border>;
    borderRadius?: Responsive<BorderRadius>;
    colEnd?: Responsive<Columns | 'auto'>;
    colSpan?: Responsive<Columns | 'full'>;
    colStart?: Responsive<Columns | 'auto'>;
    columns?: Responsive<Columns>;
    display?: Responsive<Display>;
    flexDirection?: Responsive<FlexDirection>;
    flexWrap?: Responsive<FlexWrap>;
    gap?: Responsive<Space>;
    justifyContent?: Responsive<JustifyContent>;
    rowSpan?: Responsive<Columns | 'full'>;
}
/**
 * Base type for the component styles structure
 * @public
 */
type ClassNamesMap = Record<string, string>;
/**
 * Base type for the component styles structure
 * @public
 */
type DataAttributeValues = readonly (string | number | boolean)[];
/**
 * Base type for the component styles structure
 * @public
 */
type DataAttributesMap = Record<string, DataAttributeValues>;
/**
 * Base type for the component styles structure
 * @public
 */
interface ComponentDefinition {
    classNames: ClassNamesMap;
    dataAttributes?: DataAttributesMap;
    utilityProps?: string[];
}
/**
 * Surface type
 *
 * Supports absolute levels ('0'-'3'), intent surfaces ('danger', 'warning', 'success'),
 * and 'auto' which increments from the parent surface context.
 *
 * @public
 */
type Surface = '0' | '1' | '2' | '3' | 'danger' | 'warning' | 'success' | 'auto';

/** @public */
interface BoxProps extends SpaceProps {
    display?: Responsive<'none' | 'flex' | 'block' | 'inline'>;
    as?: keyof JSX.IntrinsicElements;
    width?: Responsive<string>;
    minWidth?: Responsive<string>;
    maxWidth?: Responsive<string>;
    height?: Responsive<string>;
    minHeight?: Responsive<string>;
    maxHeight?: Responsive<string>;
    position?: Responsive<'static' | 'relative' | 'absolute' | 'fixed' | 'sticky'>;
    children?: React.ReactNode;
    className?: string;
    style?: React.CSSProperties;
    surface?: Responsive<Surface>;
}

/** @public */
declare const Box: react.ForwardRefExoticComponent<BoxProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Box
 * @public
 */
declare const BoxDefinition: {
    readonly classNames: {
        readonly root: "bui-Box";
    };
    readonly utilityProps: ["m", "mb", "ml", "mr", "mt", "mx", "my", "p", "pb", "pl", "pr", "pt", "px", "py", "position", "display", "width", "minWidth", "maxWidth", "height", "minHeight", "maxHeight"];
    readonly dataAttributes: {
        readonly surface: readonly ["0", "1", "2", "3", "danger", "warning", "success"];
    };
};

/** @public */
interface GridProps extends SpaceProps {
    children?: React.ReactNode;
    className?: string;
    columns?: Responsive<Columns>;
    gap?: Responsive<Space>;
    style?: React.CSSProperties;
    surface?: Responsive<Surface>;
}
/** @public */
interface GridItemProps {
    children?: React.ReactNode;
    className?: string;
    colSpan?: Responsive<Columns>;
    colEnd?: Responsive<Columns>;
    colStart?: Responsive<Columns>;
    rowSpan?: Responsive<Columns>;
    style?: React.CSSProperties;
    surface?: Responsive<Surface>;
}

/** @public */
declare const Grid: {
    Root: react.ForwardRefExoticComponent<GridProps & react.RefAttributes<HTMLDivElement>>;
    Item: react.ForwardRefExoticComponent<GridItemProps & react.RefAttributes<HTMLDivElement>>;
};

/**
 * Component definition for Grid
 * @public
 */
declare const GridDefinition: {
    readonly classNames: {
        readonly root: "bui-Grid";
    };
    readonly utilityProps: ["columns", "gap", "m", "mb", "ml", "mr", "mt", "mx", "my", "p", "pb", "pl", "pr", "pt", "px", "py"];
    readonly dataAttributes: {
        readonly surface: readonly ["0", "1", "2", "3", "danger", "warning", "success"];
    };
};
/**
 * Component definition for GridItem
 * @public
 */
declare const GridItemDefinition: {
    readonly classNames: {
        readonly root: "bui-GridItem";
    };
    readonly utilityProps: ["colSpan", "colEnd", "colStart", "rowSpan"];
    readonly dataAttributes: {
        readonly surface: readonly ["0", "1", "2", "3", "danger", "warning", "success"];
    };
};

/** @public */
interface FlexProps extends SpaceProps {
    children?: React.ReactNode;
    gap?: Responsive<Space>;
    align?: Responsive<'start' | 'center' | 'end' | 'baseline' | 'stretch'>;
    justify?: Responsive<'start' | 'center' | 'end' | 'between'>;
    direction?: Responsive<'row' | 'column' | 'row-reverse' | 'column-reverse'>;
    className?: string;
    style?: React.CSSProperties;
    surface?: Responsive<Surface>;
}

/** @public */
declare const Flex: react.ForwardRefExoticComponent<FlexProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Flex
 * @public
 */
declare const FlexDefinition: {
    readonly classNames: {
        readonly root: "bui-Flex";
    };
    readonly utilityProps: ["m", "mb", "ml", "mr", "mt", "mx", "my", "p", "pb", "pl", "pr", "pt", "px", "py", "gap", "align", "justify", "direction"];
    readonly dataAttributes: {
        readonly surface: readonly ["0", "1", "2", "3", "danger", "warning", "success"];
    };
};

/** @public */
interface ContainerProps {
    children?: React.ReactNode;
    className?: string;
    my?: SpaceProps['my'];
    mb?: SpaceProps['mb'];
    mt?: SpaceProps['mt'];
    py?: SpaceProps['py'];
    pb?: SpaceProps['pb'];
    pt?: SpaceProps['pt'];
    style?: React.CSSProperties;
}

/** @public */
declare const Container: react.ForwardRefExoticComponent<ContainerProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Container
 * @public
 */
declare const ContainerDefinition: {
    readonly classNames: {
        readonly root: "bui-Container";
    };
    readonly utilityProps: ["my", "mt", "mb", "py", "pt", "pb", "display"];
};

/** @public */
interface AvatarProps extends React.ComponentPropsWithoutRef<'div'> {
    /**
     * URL of the image to display
     */
    src: string;
    /**
     * Name of the person - used for generating initials and accessibility labels
     */
    name: string;
    /**
     * Size of the avatar
     * @defaultValue 'medium'
     */
    size?: 'x-small' | 'small' | 'medium' | 'large' | 'x-large';
    /**
     * Determines how the avatar is presented to assistive technologies.
     * - 'informative': Avatar is announced as "\{name\}" to screen readers
     * - 'decoration': Avatar is hidden from screen readers (use when name appears in adjacent text)
     * @defaultValue 'informative'
     */
    purpose?: 'decoration' | 'informative';
}

/** @public */
declare const Avatar: react.ForwardRefExoticComponent<AvatarProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Avatar
 * @public
 */
declare const AvatarDefinition: {
    readonly classNames: {
        readonly root: "bui-AvatarRoot";
        readonly image: "bui-AvatarImage";
        readonly fallback: "bui-AvatarFallback";
    };
    readonly dataAttributes: {
        readonly size: readonly ["small", "medium", "large"];
    };
};

/**
 * Properties for {@link Button}
 *
 * @public
 */
interface ButtonProps extends ButtonProps$1 {
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    variant?: 'primary' | 'secondary' | 'tertiary' | Partial<Record<Breakpoint, 'primary' | 'secondary' | 'tertiary'>>;
    iconStart?: ReactElement;
    iconEnd?: ReactElement;
    children?: ReactNode;
    loading?: boolean;
    /** Surface the button is placed on. Defaults to context surface if available */
    onSurface?: Responsive<Surface>;
}

/**
 * A button component built on React Aria Components that provides accessible
 * interactive elements for triggering actions.
 *
 * @remarks
 * The Button component supports multiple variants (primary, secondary, tertiary, danger),
 * sizes (small, medium), and states including loading and disabled. It automatically
 * handles keyboard navigation, focus management, and ARIA attributes for accessibility.
 *
 * @example
 * Basic usage:
 * ```tsx
 * <Button>Click me</Button>
 * ```
 *
 * @example
 * With icons and loading state:
 * ```tsx
 * <Button
 *   variant="primary"
 *   size="medium"
 *   iconStart={<IconComponent />}
 *   loading={isSubmitting}
 * >
 *   Submit
 * </Button>
 * ```
 *
 * @public
 */
declare const Button: react.ForwardRefExoticComponent<ButtonProps & react.RefAttributes<HTMLButtonElement>>;

/**
 * Component definition for Button
 * @public
 */
declare const ButtonDefinition: {
    readonly classNames: {
        readonly root: "bui-Button";
        readonly content: "bui-ButtonContent";
        readonly spinner: "bui-ButtonSpinner";
    };
    readonly dataAttributes: {
        readonly size: readonly ["small", "medium", "large"];
        readonly variant: readonly ["primary", "secondary", "tertiary"];
        readonly loading: readonly [true, false];
    };
};

/**
 * Props for the Card component.
 *
 * @public
 */
interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
    children?: React.ReactNode;
}
/**
 * Props for the CardHeader component.
 *
 * @public
 */
interface CardHeaderProps extends React.HTMLAttributes<HTMLDivElement> {
    children?: React.ReactNode;
}
/**
 * Props for the CardBody component.
 *
 * @public
 */
interface CardBodyProps extends React.HTMLAttributes<HTMLDivElement> {
    children?: React.ReactNode;
}
/**
 * Props for the CardFooter component.
 *
 * @public
 */
interface CardFooterProps extends React.HTMLAttributes<HTMLDivElement> {
    children?: React.ReactNode;
}

/**
 * Card component.
 *
 * @public
 */
declare const Card: react.ForwardRefExoticComponent<CardProps & react.RefAttributes<HTMLDivElement>>;
/**
 * CardHeader component.
 *
 * @public
 */
declare const CardHeader: react.ForwardRefExoticComponent<CardHeaderProps & react.RefAttributes<HTMLDivElement>>;
/**
 * CardBody component.
 *
 * @public
 */
declare const CardBody: react.ForwardRefExoticComponent<CardBodyProps & react.RefAttributes<HTMLDivElement>>;
/**
 * CardFooter component.
 *
 * @public
 */
declare const CardFooter: react.ForwardRefExoticComponent<CardFooterProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Card
 * @public
 */
declare const CardDefinition: {
    readonly classNames: {
        readonly root: "bui-Card";
        readonly header: "bui-CardHeader";
        readonly body: "bui-CardBody";
        readonly footer: "bui-CardFooter";
    };
};

/**
 * Props for the Accordion component.
 * @public
 */
interface AccordionProps extends DisclosureProps {
    className?: string;
}
/**
 * Props for the AccordionTrigger component.
 * @public
 */
interface AccordionTriggerProps extends HeadingProps {
    className?: string;
    title?: string;
    subtitle?: string;
    children?: React.ReactNode;
}
/**
 * Props for the AccordionPanel component.
 * @public
 */
interface AccordionPanelProps extends DisclosurePanelProps {
    className?: string;
}
/**
 * Props for the AccordionGroup component.
 * @public
 */
interface AccordionGroupProps extends DisclosureGroupProps {
    className?: string;
    /**
     * Whether multiple accordions can be expanded at the same time.
     * @defaultValue false
     */
    allowsMultiple?: boolean;
}

/** @public */
declare const Accordion: react.ForwardRefExoticComponent<AccordionProps & react.RefAttributes<HTMLDivElement>>;
/** @public */
declare const AccordionTrigger: react.ForwardRefExoticComponent<AccordionTriggerProps & react.RefAttributes<HTMLHeadingElement>>;
/** @public */
declare const AccordionPanel: react.ForwardRefExoticComponent<AccordionPanelProps & react.RefAttributes<HTMLDivElement>>;
/** @public */
declare const AccordionGroup: react.ForwardRefExoticComponent<AccordionGroupProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Accordion
 * @public
 */
declare const AccordionDefinition: {
    readonly classNames: {
        readonly root: "bui-Accordion";
        readonly trigger: "bui-AccordionTrigger";
        readonly triggerButton: "bui-AccordionTriggerButton";
        readonly triggerTitle: "bui-AccordionTriggerTitle";
        readonly triggerSubtitle: "bui-AccordionTriggerSubtitle";
        readonly triggerIcon: "bui-AccordionTriggerIcon";
        readonly panel: "bui-AccordionPanel";
        readonly group: "bui-AccordionGroup";
    };
};

/**
 * Props for the DialogTrigger component.
 * @public
 */
interface DialogTriggerProps extends DialogTriggerProps$1 {
}
/**
 * Props for the Dialog component.
 * @public
 */
interface DialogProps extends ModalOverlayProps {
    className?: string;
    children?: React.ReactNode;
    width?: number | string;
    height?: number | string;
}
/**
 * Props for the DialogHeader component.
 * @public
 */
interface DialogHeaderProps extends HeadingProps {
    children?: React.ReactNode;
    className?: string;
}
/**
 * Props for the DialogBody component.
 * @public
 */
interface DialogBodyProps {
    children?: React.ReactNode;
    className?: string;
}

/** @public */
declare const DialogTrigger: (props: DialogTriggerProps) => react_jsx_runtime.JSX.Element;
/** @public */
declare const Dialog: react.ForwardRefExoticComponent<DialogProps & react.RefAttributes<HTMLDivElement>>;
/** @public */
declare const DialogHeader: react.ForwardRefExoticComponent<DialogHeaderProps & react.RefAttributes<HTMLDivElement>>;
/** @public */
declare const DialogBody: react.ForwardRefExoticComponent<DialogBodyProps & react.RefAttributes<HTMLDivElement>>;
/** @public */
declare const DialogFooter: react.ForwardRefExoticComponent<Omit<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Dialog
 * @public
 */
declare const DialogDefinition: {
    readonly classNames: {
        readonly overlay: "bui-DialogOverlay";
        readonly dialog: "bui-Dialog";
        readonly header: "bui-DialogHeader";
        readonly headerTitle: "bui-DialogHeaderTitle";
        readonly body: "bui-DialogBody";
        readonly footer: "bui-DialogFooter";
    };
};

/** @public */
interface FieldLabelProps extends Pick<React.HTMLAttributes<HTMLDivElement>, 'className'> {
    /**
     * The label of the text field
     */
    label?: string | null;
    /**
     * The secondary label of the text field
     */
    secondaryLabel?: string | null;
    /**
     * The description of the text field
     */
    description?: string | null;
    /**
     * The HTML for attribute of the text field
     */
    htmlFor?: string;
    /**
     * The id of the text field
     */
    id?: string;
}

/** @public */
declare const FieldLabel: react.ForwardRefExoticComponent<FieldLabelProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for FieldLabel
 * @public
 */
declare const FieldLabelDefinition: {
    readonly classNames: {
        readonly root: "bui-FieldLabelWrapper";
        readonly label: "bui-FieldLabel";
        readonly secondaryLabel: "bui-FieldSecondaryLabel";
        readonly description: "bui-FieldDescription";
    };
};

/**
 * Strategies for matching the current route to determine which tab should be active.
 *
 * @public
 */
type TabMatchStrategy = 'exact' | 'prefix';
/**
 * Props for the Tabs component.
 *
 * @public
 */
interface TabsProps extends TabsProps$1 {
}
/**
 * Props for the TabList component.
 *
 * @public
 */
interface TabListProps extends Omit<TabListProps$1<object>, 'items'> {
}
/**
 * Props for the Tab component.
 *
 * @public
 */
interface TabProps extends TabProps$1 {
    /**
     * Strategy for matching the current route to determine if this tab should be active.
     * - 'exact': Tab href must exactly match the current pathname (default)
     * - 'prefix': Tab is active if current pathname starts with tab href
     */
    matchStrategy?: 'exact' | 'prefix';
}
/**
 * Props for the TabPanel component.
 *
 * @public
 */
interface TabPanelProps extends TabPanelProps$1 {
}

/**
 * A component that renders a list of tabs.
 *
 * @public
 */
declare const Tabs: (props: TabsProps) => react_jsx_runtime.JSX.Element | null;
/**
 * A component that renders a list of tabs.
 *
 * @public
 */
declare const TabList: (props: TabListProps) => react_jsx_runtime.JSX.Element;
/**
 * A component that renders a tab.
 *
 * @public
 */
declare const Tab: (props: TabProps) => react_jsx_runtime.JSX.Element;
/**
 * A component that renders the content of a tab.
 *
 * @public
 */
declare const TabPanel: (props: TabPanelProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for Tabs
 * @public
 */
declare const TabsDefinition: {
    readonly classNames: {
        readonly tabs: "bui-Tabs";
        readonly tabList: "bui-TabList";
        readonly tabListWrapper: "bui-TabListWrapper";
        readonly tab: "bui-Tab";
        readonly tabActive: "bui-TabActive";
        readonly tabHovered: "bui-TabHovered";
        readonly panel: "bui-TabPanel";
    };
};

/**
 * Props for the main Header component.
 *
 * @public
 */
interface HeaderProps {
    icon?: React.ReactNode;
    title?: string;
    titleLink?: string;
    customActions?: React.ReactNode;
    tabs?: HeaderTab[];
    onTabSelectionChange?: TabsProps$1['onSelectionChange'];
    className?: string;
}
/**
 * Represents a tab item in the header navigation.
 *
 * @public
 */
interface HeaderTab {
    id: string;
    label: string;
    href: string;
    /**
     * Strategy for matching the current route to determine if this tab should be active.
     * - 'exact': Tab href must exactly match the current pathname (default)
     * - 'prefix': Tab is active if current pathname starts with tab href
     */
    matchStrategy?: TabMatchStrategy;
}

declare module 'react-aria-components' {
    interface RouterConfig {
        routerOptions: NavigateOptions;
    }
}
/**
 * A component that renders a toolbar.
 *
 * @public
 */
declare const Header: (props: HeaderProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for Header
 * @public
 */
declare const HeaderDefinition: {
    readonly classNames: {
        readonly toolbar: "bui-HeaderToolbar";
        readonly toolbarWrapper: "bui-HeaderToolbarWrapper";
        readonly toolbarContent: "bui-HeaderToolbarContent";
        readonly toolbarControls: "bui-HeaderToolbarControls";
        readonly toolbarIcon: "bui-HeaderToolbarIcon";
        readonly toolbarName: "bui-HeaderToolbarName";
        readonly tabsWrapper: "bui-HeaderTabsWrapper";
    };
};

/**
 * Props for the main HeaderPage component.
 *
 * @public
 */
interface HeaderPageProps {
    title?: string;
    customActions?: React.ReactNode;
    tabs?: HeaderTab[];
    breadcrumbs?: HeaderPageBreadcrumb[];
    className?: string;
}
/**
 * Represents a breadcrumb item in the header.
 *
 * @public
 */
interface HeaderPageBreadcrumb {
    label: string;
    href: string;
}

/**
 * A component that renders a header page.
 *
 * @public
 */
declare const HeaderPage: (props: HeaderPageProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for HeaderPage
 * @public
 */
declare const HeaderPageDefinition: {
    readonly classNames: {
        readonly root: "bui-HeaderPage";
        readonly content: "bui-HeaderPageContent";
        readonly breadcrumbs: "bui-HeaderPageBreadcrumbs";
        readonly tabsWrapper: "bui-HeaderPageTabsWrapper";
        readonly controls: "bui-HeaderPageControls";
    };
};

/**
 * Properties for {@link ButtonIcon}
 *
 * @public
 */
interface ButtonIconProps extends ButtonProps$1 {
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    variant?: 'primary' | 'secondary' | 'tertiary' | Partial<Record<Breakpoint, 'primary' | 'secondary' | 'tertiary'>>;
    icon?: ReactElement;
    loading?: boolean;
}

/** @public */
declare const ButtonIcon: react.ForwardRefExoticComponent<ButtonIconProps & react.RefAttributes<HTMLButtonElement>>;

/**
 * Component definition for ButtonIcon
 * @public
 */
declare const ButtonIconDefinition: {
    readonly classNames: {
        readonly root: "bui-ButtonIcon";
        readonly content: "bui-ButtonIconContent";
        readonly spinner: "bui-ButtonIconSpinner";
    };
};

/**
 * Properties for {@link ButtonLink}
 *
 * @public
 */
interface ButtonLinkProps extends LinkProps$1 {
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    variant?: 'primary' | 'secondary' | 'tertiary' | Partial<Record<Breakpoint, 'primary' | 'secondary' | 'tertiary'>>;
    iconStart?: ReactElement;
    iconEnd?: ReactElement;
    children?: ReactNode;
}

/** @public */
declare const ButtonLink: react.ForwardRefExoticComponent<ButtonLinkProps & react.RefAttributes<HTMLAnchorElement>>;

/**
 * Component definition for ButtonLink
 * @public
 */
declare const ButtonLinkDefinition: {
    readonly classNames: {
        readonly root: "bui-ButtonLink";
    };
};

/** @public */
interface CheckboxProps extends CheckboxProps$1 {
    children: React.ReactNode;
}

/** @public */
declare const Checkbox: react.ForwardRefExoticComponent<CheckboxProps & react.RefAttributes<HTMLLabelElement>>;

/**
 * Component definition for Checkbox
 * @public
 */
declare const CheckboxDefinition: {
    readonly classNames: {
        readonly root: "bui-Checkbox";
        readonly indicator: "bui-CheckboxIndicator";
    };
    readonly dataAttributes: {
        readonly selected: readonly [true, false];
        readonly indeterminate: readonly [true, false];
    };
};

/** @public */
interface RadioGroupProps extends Omit<RadioGroupProps$1, 'children'>, Omit<FieldLabelProps, 'htmlFor' | 'id' | 'className'> {
    children?: ReactNode;
}
/** @public */
interface RadioProps extends RadioProps$1 {
}

/** @public */
declare const RadioGroup: react.ForwardRefExoticComponent<RadioGroupProps & react.RefAttributes<HTMLDivElement>>;
/** @public */
declare const Radio: react.ForwardRefExoticComponent<RadioProps & react.RefAttributes<HTMLLabelElement>>;

/**
 * Component definition for RadioGroup
 * @public
 */
declare const RadioGroupDefinition: {
    readonly classNames: {
        readonly root: "bui-RadioGroup";
        readonly content: "bui-RadioGroupContent";
        readonly radio: "bui-Radio";
    };
};

/** @public */
interface PageSizeOption {
    label: string;
    value: number;
}
/** @public */
interface TablePaginationProps {
    pageSize: number;
    pageSizeOptions?: number[] | PageSizeOption[];
    offset?: number;
    totalCount?: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
    onNextPage: () => void;
    onPreviousPage: () => void;
    onPageSizeChange?: (size: number) => void;
    showPageSizeOptions?: boolean;
    getLabel?: (params: {
        pageSize: number;
        offset?: number;
        totalCount?: number;
    }) => string;
}

/**
 * Pagination controls for Table components with page navigation and size selection.
 *
 * @public
 */
declare function TablePagination({ pageSize, pageSizeOptions, offset, totalCount, hasNextPage, hasPreviousPage, onNextPage, onPreviousPage, onPageSizeChange, showPageSizeOptions, getLabel, }: TablePaginationProps): react_jsx_runtime.JSX.Element;

/**
 * Component definition for TablePagination
 * @public
 */
declare const TablePaginationDefinition: {
    readonly classNames: {
        readonly root: "bui-TablePagination";
        readonly left: "bui-TablePaginationLeft";
        readonly right: "bui-TablePaginationRight";
        readonly select: "bui-TablePaginationSelect";
    };
};

/**
 * @public
 */
type SortDescriptor = SortDescriptor$1;
/** @public */
interface SortState {
    descriptor: SortDescriptor | null;
    onSortChange: (descriptor: SortDescriptor) => void;
}
/** @public */
interface CellProps extends CellProps$1 {
}
/** @public */
interface CellTextProps extends CellProps$1 {
    title: string;
    description?: string;
    color?: TextColors;
    leadingIcon?: React.ReactNode | null;
    href?: string;
}
/** @public */
interface CellProfileProps extends CellProps$1 {
    src?: string;
    name?: string;
    href?: string;
    description?: string;
    color?: TextColors;
}
/** @public */
interface ColumnProps extends Omit<ColumnProps$1, 'children'> {
    children?: React.ReactNode;
}
/** @public */
interface TableRootProps extends TableProps$1 {
    stale?: boolean;
}
/** @public */
interface TableItem {
    id: string | number;
}
/** @public */
interface NoPagination {
    type: 'none';
}
/** @public */
interface PagePagination extends TablePaginationProps {
    type: 'page';
}
/** @public */
type TablePaginationType = NoPagination | PagePagination;
/** @public */
interface ColumnConfig<T extends TableItem> {
    id: string;
    label: string;
    cell: (item: T) => ReactNode;
    header?: () => ReactNode;
    isSortable?: boolean;
    isHidden?: boolean;
    width?: ColumnSize | null;
    defaultWidth?: ColumnSize | null;
    minWidth?: ColumnStaticSize | null;
    maxWidth?: ColumnStaticSize | null;
    isRowHeader?: boolean;
}
/** @public */
interface RowConfig<T extends TableItem> {
    getHref?: (item: T) => string | undefined;
    onClick?: (item: T) => void;
    getIsDisabled?: (item: T) => boolean;
}
/** @public */
type RowRenderFn<T extends TableItem> = (params: {
    item: T;
    index: number;
}) => ReactNode;
/** @public */
interface TableSelection {
    mode?: TableProps$1['selectionMode'];
    behavior?: TableProps$1['selectionBehavior'];
    selected?: TableProps$1['selectedKeys'];
    onSelectionChange?: TableProps$1['onSelectionChange'];
}
/** @public */
interface TableProps<T extends TableItem> {
    columnConfig: readonly ColumnConfig<T>[];
    data: T[] | undefined;
    loading?: boolean;
    isStale?: boolean;
    error?: Error;
    pagination: TablePaginationType;
    sort?: SortState;
    rowConfig?: RowConfig<T> | RowRenderFn<T>;
    selection?: TableSelection;
    emptyState?: ReactNode;
    className?: string;
    style?: React.CSSProperties;
}

/** @public */
declare function Table<T extends TableItem>({ columnConfig, data, loading, isStale, error, pagination, sort, rowConfig, selection, emptyState, className, style, }: TableProps<T>): react_jsx_runtime.JSX.Element;

/** @public */
declare const TableRoot: (props: TableRootProps) => react_jsx_runtime.JSX.Element;

/** @public */
declare const TableHeader: <T extends object>(props: TableHeaderProps<T>) => react_jsx_runtime.JSX.Element;

/** @public */
declare const TableBody: <T extends object>(props: TableBodyProps<T>) => react_jsx_runtime.JSX.Element;

/** @public */
declare const Column: (props: ColumnProps) => react_jsx_runtime.JSX.Element;

/** @public */
declare function Row<T extends object>(props: RowProps<T>): react_jsx_runtime.JSX.Element;

/** @public */
declare const Cell: {
    (props: CellProps): react_jsx_runtime.JSX.Element;
    displayName: string;
};

/** @public */
declare const CellText: {
    (props: CellTextProps): react_jsx_runtime.JSX.Element;
    displayName: string;
};

/** @public */
declare const CellProfile: (props: CellProfileProps) => react_jsx_runtime.JSX.Element;

/** @public */
interface FilterState<TFilter> {
    value: TFilter | undefined;
    onChange: (value: TFilter) => void;
}
/** @public */
interface SearchState {
    value: string;
    onChange: (value: string) => void;
}
/** @public */
interface QueryOptions<TFilter> {
    initialSort?: SortDescriptor;
    sort?: SortDescriptor | null;
    onSortChange?: (sort: SortDescriptor) => void;
    initialFilter?: TFilter;
    filter?: TFilter;
    onFilterChange?: (filter: TFilter) => void;
    initialSearch?: string;
    search?: string;
    onSearchChange?: (search: string) => void;
}
/** @public */
interface PaginationOptions extends Partial<Pick<TablePaginationProps, 'pageSize' | 'pageSizeOptions' | 'onPageSizeChange' | 'onNextPage' | 'onPreviousPage' | 'showPageSizeOptions' | 'getLabel'>> {
    initialOffset?: number;
}
/** @public */
interface OffsetParams<TFilter> {
    offset: number;
    pageSize: number;
    sort: SortDescriptor | null;
    filter: TFilter | undefined;
    search: string;
    signal: AbortSignal;
}
/** @public */
interface CursorParams<TFilter> {
    cursor: string | undefined;
    pageSize: number;
    sort: SortDescriptor | null;
    filter: TFilter | undefined;
    search: string;
    signal: AbortSignal;
}
/** @public */
interface OffsetResponse<T> {
    data: T[];
    totalCount: number;
}
/** @public */
interface CursorResponse<T> {
    data: T[];
    nextCursor?: string;
    prevCursor?: string;
    totalCount?: number;
}
/** @public */
interface UseTableCompleteOptions<T extends TableItem, TFilter = unknown> extends QueryOptions<TFilter> {
    mode: 'complete';
    getData: () => T[] | Promise<T[]>;
    paginationOptions?: PaginationOptions;
    sortFn?: (data: T[], sort: SortDescriptor) => T[];
    filterFn?: (data: T[], filter: TFilter) => T[];
    searchFn?: (data: T[], search: string) => T[];
}
/** @public */
interface UseTableOffsetOptions<T extends TableItem, TFilter = unknown> extends QueryOptions<TFilter> {
    mode: 'offset';
    getData: (params: OffsetParams<TFilter>) => Promise<OffsetResponse<T>>;
    paginationOptions?: PaginationOptions;
}
/** @public */
interface UseTableCursorOptions<T extends TableItem, TFilter = unknown> extends QueryOptions<TFilter> {
    mode: 'cursor';
    getData: (params: CursorParams<TFilter>) => Promise<CursorResponse<T>>;
    paginationOptions?: Omit<PaginationOptions, 'initialOffset'>;
}
/** @public */
type UseTableOptions<T extends TableItem, TFilter = unknown> = UseTableCompleteOptions<T, TFilter> | UseTableOffsetOptions<T, TFilter> | UseTableCursorOptions<T, TFilter>;
/** @public */
interface UseTableResult<T extends TableItem, TFilter = unknown> {
    tableProps: Omit<TableProps<T>, 'columnConfig' | 'rowConfig' | 'selection' | 'emptyState'>;
    reload: () => void;
    filter: FilterState<TFilter>;
    search: SearchState;
}

/** @public */
declare function useTable<T extends TableItem, TFilter = unknown>(options: UseTableOptions<T, TFilter>): UseTableResult<T, TFilter>;

/**
 * Component definition for Table
 * @public
 */
declare const TableDefinition: {
    readonly classNames: {
        readonly table: "bui-Table";
        readonly header: "bui-TableHeader";
        readonly body: "bui-TableBody";
        readonly row: "bui-TableRow";
        readonly head: "bui-TableHead";
        readonly headContent: "bui-TableHeadContent";
        readonly headSortButton: "bui-TableHeadSortButton";
        readonly caption: "bui-TableCaption";
        readonly cell: "bui-TableCell";
        readonly cellContentWrapper: "bui-TableCellContentWrapper";
        readonly cellContent: "bui-TableCellContent";
        readonly cellIcon: "bui-TableCellIcon";
        readonly cellProfileAvatar: "bui-TableCellProfileAvatar";
        readonly cellProfileAvatarImage: "bui-TableCellProfileAvatarImage";
        readonly cellProfileAvatarFallback: "bui-TableCellProfileAvatarFallback";
        readonly cellProfileName: "bui-TableCellProfileName";
        readonly cellProfileLink: "bui-TableCellProfileLink";
        readonly headSelection: "bui-TableHeadSelection";
        readonly cellSelection: "bui-TableCellSelection";
    };
    readonly dataAttributes: {
        readonly stale: readonly [true, false];
    };
};

/**
 * Props for the TagGroup component.
 *
 * @public
 */
interface TagGroupProps<T> extends Omit<TagGroupProps$1, 'children'>, Pick<TagListProps<T>, 'items' | 'children' | 'renderEmptyState'> {
}
/**
 * Props for the Tag component.
 *
 * @public
 */
interface TagProps extends TagProps$1 {
    /**
     * The icon to display in the chip.
     */
    icon?: React.ReactNode;
    /**
     * The size of the chip.
     */
    size?: 'small' | 'medium';
}

/**
 * A component that renders a list of tags.
 *
 * @public
 */
declare const TagGroup: <T extends object>(props: TagGroupProps<T>) => react_jsx_runtime.JSX.Element;
/**
 * A component that renders a tag.
 *
 * @public
 */
declare const Tag: (props: TagProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for TagGroup
 * @public
 */
declare const TagGroupDefinition: {
    readonly classNames: {
        readonly group: "bui-TagGroup";
        readonly list: "bui-TagList";
        readonly tag: "bui-Tag";
        readonly tagIcon: "bui-TagIcon";
        readonly tagRemoveButton: "bui-TagRemoveButton";
    };
};

/** @public */
type TextOwnProps = {
    as?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'p' | 'span' | 'label' | 'div' | 'strong' | 'em' | 'small' | 'legend';
    variant?: TextVariants | Partial<Record<Breakpoint, TextVariants>>;
    weight?: TextWeights | Partial<Record<Breakpoint, TextWeights>>;
    color?: TextColors | TextColorStatus | Partial<Record<Breakpoint, TextColors | TextColorStatus>>;
    truncate?: boolean;
};
/** @public */
type TextProps<T extends ElementType = 'span'> = TextOwnProps & Omit<ComponentPropsWithRef<T>, keyof TextOwnProps>;

/** @public */
declare const Text: {
    <T extends ElementType = "p">(props: TextProps<T> & {
        ref?: React.ComponentPropsWithRef<T>["ref"];
    }): React.ReactElement<TextProps<T>, T>;
    displayName: string;
};

/**
 * Component definition for Text
 * @public
 */
declare const TextDefinition: {
    readonly classNames: {
        readonly root: "bui-Text";
    };
    readonly dataAttributes: {
        readonly variant: readonly ["subtitle", "body", "caption", "label"];
        readonly weight: readonly ["regular", "bold"];
        readonly color: readonly ["primary", "secondary", "danger", "warning", "success"];
        readonly truncate: readonly [true, false];
    };
};

/** @public */
interface TextFieldProps extends TextFieldProps$1, Omit<FieldLabelProps, 'htmlFor' | 'id' | 'className'> {
    /**
     * The HTML input type for the text field
     *
     * @remarks
     * Use `SearchField` for
     * search inputs and `PasswordField` for password inputs.
     */
    type?: 'text' | 'email' | 'tel' | 'url';
    /**
     * An icon to render before the input
     */
    icon?: ReactNode;
    /**
     * The size of the text field
     * @defaultValue 'medium'
     */
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    /**
     * Text to display in the input when it has no value
     */
    placeholder?: string;
}

/** @public */
declare const TextField: react.ForwardRefExoticComponent<TextFieldProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for TextField
 * @public
 */
declare const TextFieldDefinition: {
    readonly classNames: {
        readonly root: "bui-TextField";
        readonly inputWrapper: "bui-InputWrapper";
        readonly input: "bui-Input";
        readonly inputIcon: "bui-InputIcon";
        readonly inputAction: "bui-InputAction";
    };
    readonly dataAttributes: {
        readonly invalid: readonly [true, false];
        readonly disabled: readonly [true, false];
        readonly size: readonly ["small", "medium"];
    };
};

/** @public */
interface TooltipProps extends Omit<TooltipProps$1, 'children'> {
    children: React.ReactNode;
}

/** @public */
declare const TooltipTrigger: (props: TooltipTriggerComponentProps) => react_jsx_runtime.JSX.Element;
/** @public */
declare const Tooltip: react.ForwardRefExoticComponent<TooltipProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Tooltip
 * @public
 */
declare const TooltipDefinition: {
    readonly classNames: {
        readonly tooltip: "bui-Tooltip";
        readonly arrow: "bui-TooltipArrow";
    };
};

/** @public */
interface MenuTriggerProps extends MenuTriggerProps$1 {
}
/** @public */
interface SubmenuTriggerProps extends SubmenuTriggerProps$1 {
}
/** @public */
interface MenuProps<T> extends MenuProps$1<T>, Omit<MenuProps$1<T>, 'children'> {
    placement?: PopoverProps$1['placement'];
    virtualized?: boolean;
    maxWidth?: string;
    maxHeight?: string;
}
/** @public */
interface MenuListBoxProps<T> extends ListBoxProps<T>, Omit<ListBoxProps<T>, 'children'> {
    placement?: PopoverProps$1['placement'];
    virtualized?: boolean;
    maxWidth?: string;
    maxHeight?: string;
}
/** @public */
interface MenuAutocompleteProps<T> extends MenuProps$1<T>, Omit<MenuProps$1<T>, 'children'> {
    placeholder?: string;
    placement?: PopoverProps$1['placement'];
    virtualized?: boolean;
    maxWidth?: string;
    maxHeight?: string;
}
/** @public */
interface MenuAutocompleteListBoxProps<T> extends ListBoxProps<T>, Omit<ListBoxProps<T>, 'children'> {
    placeholder?: string;
    placement?: PopoverProps$1['placement'];
    virtualized?: boolean;
    maxWidth?: string;
    maxHeight?: string;
}
/** @public */
interface MenuItemProps extends MenuItemProps$1, Omit<MenuItemProps$1, 'children'> {
    iconStart?: React.ReactNode;
    children: React.ReactNode;
    color?: 'primary' | 'danger';
}
/** @public */
interface MenuListBoxItemProps extends ListBoxItemProps, Omit<ListBoxItemProps, 'children'> {
    children: React.ReactNode;
}
/** @public */
interface MenuSectionProps<T> extends MenuSectionProps$1<T>, Omit<MenuSectionProps$1<T>, 'children'> {
    title: string;
    children: React.ReactNode;
}
/** @public */
interface MenuSeparatorProps extends SeparatorProps {
}

/** @public */
declare const MenuTrigger: (props: MenuTriggerProps) => react_jsx_runtime.JSX.Element;
/** @public */
declare const SubmenuTrigger: (props: SubmenuTriggerProps) => react_jsx_runtime.JSX.Element;
/** @public */
declare const Menu: (props: MenuProps<object>) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuListBox: (props: MenuListBoxProps<object>) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuAutocomplete: (props: MenuAutocompleteProps<object>) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuAutocompleteListbox: (props: MenuAutocompleteListBoxProps<object>) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuItem: (props: MenuItemProps) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuListBoxItem: (props: MenuListBoxItemProps) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuSection: (props: MenuSectionProps<object>) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuSeparator: (props: MenuSeparatorProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for Menu
 * @public
 */
declare const MenuDefinition: {
    readonly classNames: {
        readonly root: "bui-Menu";
        readonly popover: "bui-MenuPopover";
        readonly content: "bui-MenuContent";
        readonly section: "bui-MenuSection";
        readonly sectionHeader: "bui-MenuSectionHeader";
        readonly item: "bui-MenuItem";
        readonly itemListBox: "bui-MenuItemListBox";
        readonly itemListBoxCheck: "bui-MenuItemListBoxCheck";
        readonly itemWrapper: "bui-MenuItemWrapper";
        readonly itemContent: "bui-MenuItemContent";
        readonly itemArrow: "bui-MenuItemArrow";
        readonly separator: "bui-MenuSeparator";
        readonly searchField: "bui-MenuSearchField";
        readonly searchFieldInput: "bui-MenuSearchFieldInput";
        readonly searchFieldClear: "bui-MenuSearchFieldClear";
        readonly emptyState: "bui-MenuEmptyState";
    };
};

/**
 * Properties for {@link Popover}
 *
 * @public
 */
interface PopoverProps extends Omit<PopoverProps$1, 'children'> {
    /**
     * The content to display inside the popover.
     * Content is automatically wrapped with padding and scroll behavior.
     */
    children: React.ReactNode;
    /**
     * Whether to hide the arrow pointing to the trigger element.
     * Arrow is also automatically hidden for MenuTrigger and SubmenuTrigger contexts.
     *
     * @defaultValue false
     */
    hideArrow?: boolean;
}

/**
 * A popover component built on React Aria Components that displays floating
 * content anchored to a trigger element.
 *
 * @remarks
 * The Popover component supports multiple placements (top, right, bottom, left),
 * automatic viewport-constrained scrolling, and conditional arrow rendering. It
 * automatically handles positioning, collision detection, and ARIA attributes for
 * accessibility. Content is automatically padded and scrollable when it exceeds
 * available space.
 *
 * @example
 * Basic usage with DialogTrigger:
 * ```tsx
 * <DialogTrigger>
 *   <Button>Open Popover</Button>
 *   <Popover>
 *     <Text>Popover content</Text>
 *   </Popover>
 * </DialogTrigger>
 * ```
 *
 * @example
 * With custom placement and no arrow:
 * ```tsx
 * <DialogTrigger>
 *   <Button>Open</Button>
 *   <Popover placement="right" hideArrow>
 *     <Text>Content without arrow</Text>
 *   </Popover>
 * </DialogTrigger>
 * ```
 *
 * @public
 */
declare const Popover: react.ForwardRefExoticComponent<PopoverProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Popover
 * @public
 */
declare const PopoverDefinition: {
    readonly classNames: {
        readonly root: "bui-Popover";
        readonly arrow: "bui-PopoverArrow";
        readonly content: "bui-PopoverContent";
    };
};

/** @public */
interface SearchFieldProps extends SearchFieldProps$1, Omit<FieldLabelProps, 'htmlFor' | 'id' | 'className'> {
    /**
     * An icon to render before the input
     */
    icon?: ReactNode | false;
    /**
     * The size of the text field
     * @defaultValue 'medium'
     */
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    /**
     * The placeholder text for the input
     */
    placeholder?: string;
    /**
     * Controls whether the SearchField starts in a collapsed state.
     */
    startCollapsed?: boolean;
}

/** @public */
declare const SearchField: react.ForwardRefExoticComponent<SearchFieldProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for SearchField
 * @public
 */
declare const SearchFieldDefinition: {
    readonly classNames: {
        readonly root: "bui-SearchField";
        readonly clear: "bui-SearchFieldClear";
        readonly inputWrapper: "bui-SearchFieldInputWrapper";
        readonly input: "bui-SearchFieldInput";
        readonly inputIcon: "bui-SearchFieldInputIcon";
    };
    readonly dataAttributes: {
        readonly startCollapsed: readonly [true, false];
        readonly size: readonly ["small", "medium"];
    };
};

/** @public */
interface LinkProps extends LinkProps$1 {
    variant?: TextVariants | Partial<Record<Breakpoint, TextVariants>>;
    weight?: TextWeights | Partial<Record<Breakpoint, TextWeights>>;
    color?: TextColors | TextColorStatus | Partial<Record<Breakpoint, TextColors | TextColorStatus>>;
    truncate?: boolean;
    title?: string;
    children?: ReactNode;
}

/** @public */
declare const Link: react.ForwardRefExoticComponent<LinkProps & react.RefAttributes<HTMLAnchorElement>>;

/**
 * Component definition for Link
 * @public
 */
declare const LinkDefinition: {
    readonly classNames: {
        readonly root: "bui-Link";
    };
    readonly dataAttributes: {
        readonly variant: readonly ["subtitle", "body", "caption", "label"];
        readonly weight: readonly ["regular", "bold"];
        readonly color: readonly ["primary", "secondary", "danger", "warning", "success"];
        readonly truncate: readonly [true, false];
    };
};

/** @public */
type Option = {
    value: string;
    label: string;
    disabled?: boolean;
};
/** @public */
interface SelectProps<T extends 'single' | 'multiple'> extends SelectProps$1<Option, T>, Omit<FieldLabelProps, 'htmlFor' | 'id' | 'className'> {
    /**
     * An icon to render before the input
     */
    icon?: ReactNode;
    /**
     * The size of the select field
     * @defaultValue 'small'
     */
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    /**
     * The options of the select field
     */
    options?: Array<Option>;
    /**
     * Enable search/filter functionality in the dropdown
     * @defaultValue false
     */
    searchable?: boolean;
    /**
     * placeholder text for the search input
     * only used when searchable is true
     * @defaultvalue 'search...'
     */
    searchPlaceholder?: string;
    /**
     * Selection mode, single or multiple
     * @defaultvalue 'single'
     */
    selectionMode?: T;
}

/** @public */
declare const Select: react.ForwardRefExoticComponent<SelectProps<"multiple" | "single"> & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Select
 * @public
 */
declare const SelectDefinition: {
    readonly classNames: {
        readonly root: "bui-Select";
        readonly popover: "bui-SelectPopover";
        readonly trigger: "bui-SelectTrigger";
        readonly chevron: "bui-SelectTriggerChevron";
        readonly value: "bui-SelectValue";
        readonly list: "bui-SelectList";
        readonly item: "bui-SelectItem";
        readonly itemIndicator: "bui-SelectItemIndicator";
        readonly itemLabel: "bui-SelectItemLabel";
        readonly searchWrapper: "bui-SelectSearchWrapper";
        readonly search: "bui-SelectSearch";
        readonly searchClear: "bui-SelectSearchClear";
        readonly noResults: "bui-SelectNoResults";
    };
    readonly dataAttributes: {
        readonly size: readonly ["small", "medium"];
    };
};

/** @public */
interface SkeletonProps extends ComponentProps<'div'> {
    width?: number | string;
    height?: number | string;
    rounded?: boolean;
}

/** @public */
declare const Skeleton: (props: SkeletonProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for Skeleton
 * @public
 */
declare const SkeletonDefinition: {
    readonly classNames: {
        readonly root: "bui-Skeleton";
    };
};

/** @public */
interface SwitchProps extends SwitchProps$1 {
    /**
     * The label of the switch
     */
    label?: string;
}

/** @public */
declare const Switch: react.ForwardRefExoticComponent<SwitchProps & react.RefAttributes<HTMLLabelElement>>;

/**
 * Component definition for Switch
 * @public
 */
declare const SwitchDefinition: {
    readonly classNames: {
        readonly root: "bui-Switch";
        readonly indicator: "bui-SwitchIndicator";
    };
};

/**
 * Properties for {@link ToggleButton}
 *
 * @public
 */
interface ToggleButtonProps extends ToggleButtonProps$1 {
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    iconStart?: ReactElement;
    iconEnd?: ReactElement;
    /** Surface the toggle button is placed on. Defaults to context surface if available */
    onSurface?: Responsive<Surface>;
}

/** @public */
declare const ToggleButton: react.ForwardRefExoticComponent<ToggleButtonProps & react.RefAttributes<HTMLButtonElement>>;

/**
 * Component definition for ToggleButton
 * @public
 */
declare const ToggleButtonDefinition: {
    readonly classNames: {
        readonly root: "bui-ToggleButton";
        readonly content: "bui-ToggleButtonContent";
    };
    readonly dataAttributes: {
        readonly size: readonly ["small", "medium"];
    };
};

/** @public */
interface ToggleButtonGroupProps extends Omit<ToggleButtonGroupProps$1, 'orientation'> {
    orientation?: NonNullable<ToggleButtonGroupProps$1['orientation']>;
}

/** @public */
declare const ToggleButtonGroup: react.ForwardRefExoticComponent<ToggleButtonGroupProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for ToggleButtonGroup
 * @public
 */
declare const ToggleButtonGroupDefinition: {
    readonly classNames: {
        readonly root: "bui-ToggleButtonGroup";
    };
    readonly dataAttributes: {
        readonly orientation: readonly ["horizontal", "vertical"];
    };
};

/**
 * Properties for {@link VisuallyHidden}
 *
 * @public
 */
interface VisuallyHiddenProps extends ComponentProps<'div'> {
    children?: React.ReactNode;
}

/**
 * Visually hides content while keeping it accessible to screen readers.
 * Useful for descriptive labels and other screen-reader-only content.
 *
 * Note: This component is for content that should ALWAYS remain visually hidden.
 * For skip links that become visible on focus, use a different approach.
 *
 * @public
 */
declare const VisuallyHidden: (props: VisuallyHiddenProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for VisuallyHidden
 * @public
 */
declare const VisuallyHiddenDefinition: {
    readonly classNames: {
        readonly root: "bui-VisuallyHidden";
    };
};

/** @public */
declare const useBreakpoint: () => {
    breakpoint: Breakpoint;
    up: (key: Breakpoint) => boolean;
    down: (key: Breakpoint) => boolean;
};

export { Accordion, AccordionDefinition, AccordionGroup, AccordionPanel, AccordionTrigger, Avatar, AvatarDefinition, Box, BoxDefinition, Button, ButtonDefinition, ButtonIcon, ButtonIconDefinition, ButtonLink, ButtonLinkDefinition, Card, CardBody, CardDefinition, CardFooter, CardHeader, Cell, CellProfile, CellText, Checkbox, CheckboxDefinition, Column, Container, ContainerDefinition, Dialog, DialogBody, DialogDefinition, DialogFooter, DialogHeader, DialogTrigger, FieldLabel, FieldLabelDefinition, Flex, FlexDefinition, Grid, GridDefinition, GridItemDefinition, Header, HeaderDefinition, HeaderPage, HeaderPageDefinition, Link, LinkDefinition, Menu, MenuAutocomplete, MenuAutocompleteListbox, MenuDefinition, MenuItem, MenuListBox, MenuListBoxItem, MenuSection, MenuSeparator, MenuTrigger, Popover, PopoverDefinition, Radio, RadioGroup, RadioGroupDefinition, Row, SearchField, SearchFieldDefinition, Select, SelectDefinition, Skeleton, SkeletonDefinition, SubmenuTrigger, Switch, SwitchDefinition, Tab, TabList, TabPanel, Table, TableBody, TableDefinition, TableHeader, TablePagination, TablePaginationDefinition, TableRoot, Tabs, TabsDefinition, Tag, TagGroup, TagGroupDefinition, Text, TextDefinition, TextField, TextFieldDefinition, ToggleButton, ToggleButtonDefinition, ToggleButtonGroup, ToggleButtonGroupDefinition, Tooltip, TooltipDefinition, TooltipTrigger, VisuallyHidden, VisuallyHiddenDefinition, useBreakpoint, useTable };
export type { AccordionGroupProps, AccordionPanelProps, AccordionProps, AccordionTriggerProps, AlignItems, AvatarProps, Border, BorderRadius, BoxProps, Breakpoint, ButtonIconProps, ButtonLinkProps, ButtonProps, CardBodyProps, CardFooterProps, CardHeaderProps, CardProps, CellProfileProps, CellProps, CellTextProps, CheckboxProps, ClassNamesMap, ColumnConfig, ColumnProps, Columns, ComponentDefinition, ContainerProps, CursorParams, CursorResponse, DataAttributeValues, DataAttributesMap, DialogBodyProps, DialogHeaderProps, DialogProps, DialogTriggerProps, Display, FieldLabelProps, FilterState, FlexDirection, FlexProps, FlexWrap, GridItemProps, GridProps, HeaderPageBreadcrumb, HeaderPageProps, HeaderProps, HeaderTab, JustifyContent, LinkProps, MenuAutocompleteListBoxProps, MenuAutocompleteProps, MenuItemProps, MenuListBoxItemProps, MenuListBoxProps, MenuProps, MenuSectionProps, MenuSeparatorProps, MenuTriggerProps, NoPagination, OffsetParams, OffsetResponse, Option, PagePagination, PageSizeOption, PaginationOptions, PopoverProps, QueryOptions, RadioGroupProps, RadioProps, Responsive, RowConfig, RowRenderFn, SearchFieldProps, SearchState, SelectProps, SkeletonProps, SortDescriptor, SortState, Space, SpaceProps, SubmenuTriggerProps, Surface, SwitchProps, TabListProps, TabMatchStrategy, TabPanelProps, TabProps, TableItem, TablePaginationProps, TablePaginationType, TableProps, TableRootProps, TableSelection, TabsProps, TagGroupProps, TagProps, TextColorStatus, TextColors, TextFieldProps, TextOwnProps, TextProps, TextVariants, TextWeights, ToggleButtonGroupProps, ToggleButtonProps, TooltipProps, UseTableCompleteOptions, UseTableCursorOptions, UseTableOffsetOptions, UseTableOptions, UseTableResult, UtilityProps, VisuallyHiddenProps };
