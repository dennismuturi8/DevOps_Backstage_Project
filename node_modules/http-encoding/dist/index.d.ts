import * as zlib from 'zlib';
export type SUPPORTED_ENCODING = 'identity' | 'gzip' | 'x-gzip' | 'deflate' | 'x-deflate' | 'br' | 'zstd' | 'base64';
export declare const gzip: typeof zlib.gzip.__promisify__;
export declare const gunzip: typeof zlib.gunzip.__promisify__;
export declare const deflate: typeof zlib.deflate.__promisify__;
export declare const deflateRaw: typeof zlib.deflateRaw.__promisify__;
export declare const inflate: typeof zlib.inflate.__promisify__;
export declare const inflateRaw: typeof zlib.inflateRaw.__promisify__;
export declare const brotliCompress: (buffer: Uint8Array, level?: number) => Promise<Uint8Array>;
export declare const brotliDecompress: typeof zlib.brotliDecompress.__promisify__ | ((buffer: Uint8Array) => Promise<Uint8Array>);
export declare const zstdCompress: (buffer: Uint8Array, level?: number) => Promise<Uint8Array>;
export declare const zstdDecompress: (buffer: Uint8Array) => Promise<Uint8Array>;
export declare const encodeBase64: (buffer: Uint8Array) => Promise<Uint8Array>;
export declare const decodeBase64: (buffer: Uint8Array) => Promise<Uint8Array>;
type BufferSource = ArrayBufferView | ArrayBuffer;
export declare function createGzipStream(): TransformStream<BufferSource, Uint8Array>;
export declare function createGunzipStream(): TransformStream<BufferSource, Uint8Array>;
export declare function createDeflateStream(): TransformStream<BufferSource, Uint8Array>;
export declare function createInflateStream(): TransformStream<BufferSource, Uint8Array>;
export declare function createDeflateRawStream(): TransformStream<BufferSource, Uint8Array>;
export declare function createInflateRawStream(): TransformStream<BufferSource, Uint8Array>;
export declare function createBrotliCompressStream(): TransformStream<BufferSource, Uint8Array>;
export declare function createBrotliDecompressStream(): TransformStream<BufferSource, Uint8Array>;
export declare function createZstdCompressStream(): TransformStream<BufferSource, Uint8Array>;
export declare function createZstdDecompressStream(): TransformStream<BufferSource, Uint8Array>;
export declare function createBase64EncodeStream(): TransformStream<BufferSource, Uint8Array>;
export declare function createBase64DecodeStream(): TransformStream<BufferSource, Uint8Array>;
/**
 * Creates a decode stream for the given content-encoding header value.
 * Supports multiple encodings (comma-separated or array), applied in reverse order.
 * Returns null if no decoding is needed (identity or no encoding).
 *
 * @example
 * const decoder = createDecodeStream('gzip');
 * const output = decoder ? stream.pipeThrough(decoder) : stream;
 *
 * @example
 * // Multiple encodings (decodes in reverse order)
 * const decoder = createDecodeStream('gzip, br');
 */
export declare function createDecodeStream(encoding: string | string[] | undefined): TransformStream<BufferSource, Uint8Array> | null;
/**
 * Creates an encode stream for the given content-encoding header value.
 * Supports multiple encodings (comma-separated or array), applied in order.
 * Returns null if no encoding is needed (identity or no encoding).
 *
 * @example
 * const encoder = createEncodeStream('gzip');
 * const output = encoder ? stream.pipeThrough(encoder) : stream;
 *
 * @example
 * // Multiple encodings (applies gzip first, then base64)
 * const encoder = createEncodeStream('gzip, base64');
 */
export declare function createEncodeStream(encoding: string | string[] | undefined): TransformStream<BufferSource, Uint8Array> | null;
/**
 * Decodes a buffer, using the encodings as specified in a content-encoding header. Returns
 * a Buffer instance in Node, or a Uint8Array in a browser.
 *
 * Throws if any unrecognized/unavailable content-encoding is found.
 */
export declare function decodeBuffer(body: Uint8Array | ArrayBuffer, encoding: string | string[] | undefined): Promise<Buffer>;
/**
 * Decodes a buffer, using the encodings as specified in a content-encoding header, synchronously.
 * Returns a Buffer instance in Node, or a Uint8Array in a browser.
 *
 * Zstandard and Brotli decoding are not be supported in synchronous usage.
 *
 * Throws if any unrecognized/unavailable content-encoding is found.
 *
 * @deprecated This is here for convenience with some existing APIs, but for performance & consistency
 * async usage with decodeBuffer is preferable.
 */
export declare function decodeBufferSync(body: Uint8Array | ArrayBuffer, encoding: string | string[] | undefined): Buffer;
/**
 * Encodes a buffer, given a single encoding name (as used in content-encoding headers), and an optional
 * level. Returns a Buffer instance in Node, or a Uint8Array in a browser.
 *
 * Throws if an unrecognized/unavailable encoding is specified
 */
export declare function encodeBuffer(body: Uint8Array | ArrayBuffer, encoding: SUPPORTED_ENCODING, options?: {
    level?: number;
}): Promise<Buffer>;
export {};
