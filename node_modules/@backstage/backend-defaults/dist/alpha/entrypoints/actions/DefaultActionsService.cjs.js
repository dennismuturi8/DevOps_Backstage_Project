'use strict';

var errors = require('@backstage/errors');
var minimatch = require('minimatch');

class DefaultActionsService {
  discovery;
  config;
  logger;
  auth;
  constructor(discovery, config, logger, auth) {
    this.discovery = discovery;
    this.config = config;
    this.logger = logger;
    this.auth = auth;
  }
  static create({
    discovery,
    config,
    logger,
    auth
  }) {
    return new DefaultActionsService(discovery, config, logger, auth);
  }
  async list({ credentials }) {
    const pluginSources = this.config.getOptionalStringArray("backend.actions.pluginSources") ?? [];
    const remoteActionsList = await Promise.all(
      pluginSources.map(async (source) => {
        try {
          const response = await this.makeRequest({
            path: `/.backstage/actions/v1/actions`,
            pluginId: source,
            credentials
          });
          if (!response.ok) {
            throw await errors.ResponseError.fromResponse(response);
          }
          const { actions } = await response.json();
          return actions;
        } catch (error) {
          this.logger.warn(`Failed to fetch actions from ${source}`, error);
          return [];
        }
      })
    );
    return { actions: this.applyFilters(remoteActionsList.flat()) };
  }
  async invoke(opts) {
    const pluginId = this.pluginIdFromActionId(opts.id);
    const response = await this.makeRequest({
      path: `/.backstage/actions/v1/actions/${encodeURIComponent(
        opts.id
      )}/invoke`,
      pluginId,
      credentials: opts.credentials,
      options: {
        method: "POST",
        body: JSON.stringify(opts.input),
        headers: {
          "Content-Type": "application/json"
        }
      }
    });
    if (!response.ok) {
      throw await errors.ResponseError.fromResponse(response);
    }
    const { output } = await response.json();
    return { output };
  }
  async makeRequest(opts) {
    const { path, pluginId, credentials, options } = opts;
    const baseUrl = await this.discovery.getBaseUrl(pluginId);
    const { token } = await this.auth.getPluginRequestToken({
      onBehalfOf: credentials,
      targetPluginId: opts.pluginId
    });
    return fetch(`${baseUrl}${path}`, {
      ...options,
      headers: {
        ...options?.headers,
        Authorization: `Bearer ${token}`
      }
    });
  }
  pluginIdFromActionId(id) {
    const colonIndex = id.indexOf(":");
    if (colonIndex === -1) {
      throw new Error(`Invalid action id: ${id}`);
    }
    return id.substring(0, colonIndex);
  }
  applyFilters(actions) {
    const filterConfig = this.config.getOptionalConfig(
      "backend.actions.filter"
    );
    if (!filterConfig) {
      return actions;
    }
    const includeRules = this.parseFilterRules(
      filterConfig.getOptionalConfigArray("include") ?? []
    );
    const excludeRules = this.parseFilterRules(
      filterConfig.getOptionalConfigArray("exclude") ?? []
    );
    return actions.filter((action) => {
      const excluded = excludeRules.some(
        (rule) => this.matchesRule(action, rule)
      );
      if (excluded) {
        return false;
      }
      if (includeRules.length === 0) {
        return true;
      }
      return includeRules.some((rule) => this.matchesRule(action, rule));
    });
  }
  parseFilterRules(configArray) {
    return configArray.map((ruleConfig) => {
      const idPattern = ruleConfig.getOptionalString("id");
      const attributesConfig = ruleConfig.getOptionalConfig("attributes");
      const rule = {};
      if (idPattern) {
        rule.idMatcher = new minimatch.Minimatch(idPattern);
      }
      if (attributesConfig) {
        rule.attributes = {};
        for (const key of ["destructive", "readOnly", "idempotent"]) {
          const value = attributesConfig.getOptionalBoolean(key);
          if (value !== void 0) {
            rule.attributes[key] = value;
          }
        }
      }
      return rule;
    });
  }
  matchesRule(action, rule) {
    if (rule.idMatcher && !rule.idMatcher.match(action.id)) {
      return false;
    }
    if (rule.attributes) {
      for (const [key, value] of Object.entries(rule.attributes)) {
        if (action.attributes[key] !== value) {
          return false;
        }
      }
    }
    return true;
  }
}

exports.DefaultActionsService = DefaultActionsService;
//# sourceMappingURL=DefaultActionsService.cjs.js.map
