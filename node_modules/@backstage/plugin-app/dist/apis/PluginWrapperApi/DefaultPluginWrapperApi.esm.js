import { jsx } from 'react/jsx-runtime';
import { useState, useEffect, useMemo } from 'react';

class DefaultPluginWrapperApi {
  constructor(pluginWrappers) {
    this.pluginWrappers = pluginWrappers;
  }
  getPluginWrapper(pluginId) {
    return this.pluginWrappers.get(pluginId);
  }
  static fromWrappers(wrappers) {
    const loadersByPlugin = /* @__PURE__ */ new Map();
    for (const wrapper of wrappers) {
      let loaders = loadersByPlugin.get(wrapper.pluginId);
      if (!loaders) {
        loaders = [];
        loadersByPlugin.set(wrapper.pluginId, loaders);
      }
      loaders.push(wrapper.loader);
    }
    const composedWrappers = /* @__PURE__ */ new Map();
    for (const [pluginId, loaders] of loadersByPlugin) {
      if (loaders.length === 0) {
        continue;
      }
      const ComposedWrapper = (props) => {
        const [loadedWrappers, setLoadedWrappers] = useState(void 0);
        const [error, setError] = useState(void 0);
        useEffect(() => {
          Promise.all(loaders.map((loader) => loader())).then((results) => {
            setLoadedWrappers(results.map((r) => r.component));
          }).catch(setError);
        }, []);
        if (error) {
          throw error;
        }
        return useMemo(() => {
          if (!loadedWrappers) {
            return null;
          }
          let current = props.children;
          for (const Wrapper of loadedWrappers) {
            current = /* @__PURE__ */ jsx(Wrapper, { children: current });
          }
          return current;
        }, [loadedWrappers, props.children]);
      };
      composedWrappers.set(pluginId, ComposedWrapper);
    }
    return new DefaultPluginWrapperApi(composedWrappers);
  }
}

export { DefaultPluginWrapperApi };
//# sourceMappingURL=DefaultPluginWrapperApi.esm.js.map
